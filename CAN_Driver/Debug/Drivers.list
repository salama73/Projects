
Drivers.axf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000181c  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000000c  0800194c  0800194c  0001194c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08001958  08001958  00020008  2**0
                  CONTENTS
  4 .ARM          00000000  08001958  08001958  00020008  2**0
                  CONTENTS
  5 .preinit_array 00000000  08001958  08001958  00020008  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08001958  08001958  00011958  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800195c  0800195c  0001195c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000008  20000000  08001960  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000404  20000008  08001968  00020008  2**2
                  ALLOC
 10 ._user_heap_stack 00000204  2000040c  08001968  0002040c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
 12 .debug_info   00005f9c  00000000  00000000  00020031  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00000f66  00000000  00000000  00025fcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000017ea  00000000  00000000  00026f33  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000380  00000000  00000000  00028720  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000308  00000000  00000000  00028aa0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  0000273b  00000000  00000000  00028da8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00003195  00000000  00000000  0002b4e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00012f55  00000000  00000000  0002e678  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  000415cd  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000c20  00000000  00000000  00041648  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000008 	.word	0x20000008
 800014c:	00000000 	.word	0x00000000
 8000150:	08001934 	.word	0x08001934

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	2000000c 	.word	0x2000000c
 800016c:	08001934 	.word	0x08001934

08000170 <strcmp>:
 8000170:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000174:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000178:	2a01      	cmp	r2, #1
 800017a:	bf28      	it	cs
 800017c:	429a      	cmpcs	r2, r3
 800017e:	d0f7      	beq.n	8000170 <strcmp>
 8000180:	1ad0      	subs	r0, r2, r3
 8000182:	4770      	bx	lr

08000184 <HardFault_Handler>:
#include "Cortex_Mx_Porting.h"

uint8_t SysTickLED;

void HardFault_Handler(void)
{
 8000184:	b480      	push	{r7}
 8000186:	af00      	add	r7, sp, #0
	while(1);
 8000188:	e7fe      	b.n	8000188 <HardFault_Handler+0x4>

0800018a <MemManage_Handler>:
}

void MemManage_Handler(void)
{
 800018a:	b480      	push	{r7}
 800018c:	af00      	add	r7, sp, #0
	while(1);
 800018e:	e7fe      	b.n	800018e <MemManage_Handler+0x4>

08000190 <UsageFault_Handler>:
{
	while(1);
}

void UsageFault_Handler(void)
{
 8000190:	b480      	push	{r7}
 8000192:	af00      	add	r7, sp, #0
	while(1);
 8000194:	e7fe      	b.n	8000194 <UsageFault_Handler+0x4>

08000196 <SVC_Handler>:
}

__attribute((naked)) void SVC_Handler (void)
{
    __asm(  "TST LR,#4\n\t"
 8000196:	f01e 0f04 	tst.w	lr, #4
 800019a:	bf0c      	ite	eq
 800019c:	f3ef 8008 	mrseq	r0, MSP
 80001a0:	f3ef 8009 	mrsne	r0, PSP
 80001a4:	f000 ba94 	b.w	80006d0 <OS_SV>
    		"ITE EQ \n\t"
    		"MRSEQ R0,MSP\n\t"
    		"MRSNE R0,PSP\n\t"
    		"B OS_SV");
}
 80001a8:	bf00      	nop
	...

080001ac <trigger_OS_PendSV>:
	 */
	__NVIC_SetPriority(PendSV_IRQn, 15) ;

}
void trigger_OS_PendSV()
{
 80001ac:	b480      	push	{r7}
 80001ae:	af00      	add	r7, sp, #0
	SCB->ICSR|=SCB_ICSR_PENDSVSET_Msk;
 80001b0:	4b04      	ldr	r3, [pc, #16]	; (80001c4 <trigger_OS_PendSV+0x18>)
 80001b2:	685b      	ldr	r3, [r3, #4]
 80001b4:	4a03      	ldr	r2, [pc, #12]	; (80001c4 <trigger_OS_PendSV+0x18>)
 80001b6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80001ba:	6053      	str	r3, [r2, #4]
}
 80001bc:	bf00      	nop
 80001be:	46bd      	mov	sp, r7
 80001c0:	bc80      	pop	{r7}
 80001c2:	4770      	bx	lr
 80001c4:	e000ed00 	.word	0xe000ed00

080001c8 <SysTick_Handler>:
	 */
	 SysTick_Config(8000);
}

void SysTick_Handler(void)
{
 80001c8:	b580      	push	{r7, lr}
 80001ca:	af00      	add	r7, sp, #0
	SysTickLED ^= 1 ;
 80001cc:	4b07      	ldr	r3, [pc, #28]	; (80001ec <SysTick_Handler+0x24>)
 80001ce:	781b      	ldrb	r3, [r3, #0]
 80001d0:	f083 0301 	eor.w	r3, r3, #1
 80001d4:	b2da      	uxtb	r2, r3
 80001d6:	4b05      	ldr	r3, [pc, #20]	; (80001ec <SysTick_Handler+0x24>)
 80001d8:	701a      	strb	r2, [r3, #0]
	//MYRTOS_Update_TasksWaitingTime();
	MYRTOS_Update_TasksWaitingTime();
 80001da:	f000 facf 	bl	800077c <MYRTOS_Update_TasksWaitingTime>
	//Determine Pcurrent & Pnext
	Decide_whatNext();
 80001de:	f000 fa25 	bl	800062c <Decide_whatNext>
	//Switch Context & restore
	trigger_OS_PendSV();
 80001e2:	f7ff ffe3 	bl	80001ac <trigger_OS_PendSV>
}
 80001e6:	bf00      	nop
 80001e8:	bd80      	pop	{r7, pc}
 80001ea:	bf00      	nop
 80001ec:	2000002c 	.word	0x2000002c

080001f0 <FIFO_enqueue>:

}

/* *********************************** */

Buffer_status FIFO_enqueue (FIFO_Buf_t* fifo,element_type item){
 80001f0:	b480      	push	{r7}
 80001f2:	b083      	sub	sp, #12
 80001f4:	af00      	add	r7, sp, #0
 80001f6:	6078      	str	r0, [r7, #4]
 80001f8:	6039      	str	r1, [r7, #0]

	/* fifo null*/

	if (!fifo->base || !fifo->length)
 80001fa:	687b      	ldr	r3, [r7, #4]
 80001fc:	68db      	ldr	r3, [r3, #12]
 80001fe:	2b00      	cmp	r3, #0
 8000200:	d003      	beq.n	800020a <FIFO_enqueue+0x1a>
 8000202:	687b      	ldr	r3, [r7, #4]
 8000204:	691b      	ldr	r3, [r3, #16]
 8000206:	2b00      	cmp	r3, #0
 8000208:	d101      	bne.n	800020e <FIFO_enqueue+0x1e>
		return FIFO_NULL;
 800020a:	2303      	movs	r3, #3
 800020c:	e02d      	b.n	800026a <FIFO_enqueue+0x7a>
	/*fifo is full*/

	/* fifo full */
	if ((fifo->head == fifo->tail) && (fifo->counter == fifo->length))
 800020e:	687b      	ldr	r3, [r7, #4]
 8000210:	685a      	ldr	r2, [r3, #4]
 8000212:	687b      	ldr	r3, [r7, #4]
 8000214:	689b      	ldr	r3, [r3, #8]
 8000216:	429a      	cmp	r2, r3
 8000218:	d107      	bne.n	800022a <FIFO_enqueue+0x3a>
 800021a:	687b      	ldr	r3, [r7, #4]
 800021c:	681a      	ldr	r2, [r3, #0]
 800021e:	687b      	ldr	r3, [r7, #4]
 8000220:	691b      	ldr	r3, [r3, #16]
 8000222:	429a      	cmp	r2, r3
 8000224:	d101      	bne.n	800022a <FIFO_enqueue+0x3a>
		return FIFO_FULL;
 8000226:	2301      	movs	r3, #1
 8000228:	e01f      	b.n	800026a <FIFO_enqueue+0x7a>

	*(fifo->tail)=item;
 800022a:	687b      	ldr	r3, [r7, #4]
 800022c:	689b      	ldr	r3, [r3, #8]
 800022e:	683a      	ldr	r2, [r7, #0]
 8000230:	601a      	str	r2, [r3, #0]
	fifo->counter++;
 8000232:	687b      	ldr	r3, [r7, #4]
 8000234:	681b      	ldr	r3, [r3, #0]
 8000236:	1c5a      	adds	r2, r3, #1
 8000238:	687b      	ldr	r3, [r7, #4]
 800023a:	601a      	str	r2, [r3, #0]

	/*for circular fifo again */

	/* circular enqueue */
	if (fifo->tail == (((unsigned int)fifo->base + (4*fifo->length )) - 4 ))
 800023c:	687b      	ldr	r3, [r7, #4]
 800023e:	689b      	ldr	r3, [r3, #8]
 8000240:	687a      	ldr	r2, [r7, #4]
 8000242:	68d2      	ldr	r2, [r2, #12]
 8000244:	4611      	mov	r1, r2
 8000246:	687a      	ldr	r2, [r7, #4]
 8000248:	6912      	ldr	r2, [r2, #16]
 800024a:	0092      	lsls	r2, r2, #2
 800024c:	440a      	add	r2, r1
 800024e:	3a04      	subs	r2, #4
 8000250:	4293      	cmp	r3, r2
 8000252:	d104      	bne.n	800025e <FIFO_enqueue+0x6e>
		fifo->tail = fifo->base;
 8000254:	687b      	ldr	r3, [r7, #4]
 8000256:	68da      	ldr	r2, [r3, #12]
 8000258:	687b      	ldr	r3, [r7, #4]
 800025a:	609a      	str	r2, [r3, #8]
 800025c:	e004      	b.n	8000268 <FIFO_enqueue+0x78>
	else
		fifo->tail++;
 800025e:	687b      	ldr	r3, [r7, #4]
 8000260:	689b      	ldr	r3, [r3, #8]
 8000262:	1d1a      	adds	r2, r3, #4
 8000264:	687b      	ldr	r3, [r7, #4]
 8000266:	609a      	str	r2, [r3, #8]

	return FIFO_NO_ERROR;
 8000268:	2300      	movs	r3, #0


}
 800026a:	4618      	mov	r0, r3
 800026c:	370c      	adds	r7, #12
 800026e:	46bd      	mov	sp, r7
 8000270:	bc80      	pop	{r7}
 8000272:	4770      	bx	lr

08000274 <FIFO_dequeue>:

/* *********************************** */

Buffer_status FIFO_dequeue (FIFO_Buf_t* fifo, element_type* item){
 8000274:	b480      	push	{r7}
 8000276:	b083      	sub	sp, #12
 8000278:	af00      	add	r7, sp, #0
 800027a:	6078      	str	r0, [r7, #4]
 800027c:	6039      	str	r1, [r7, #0]
	/* check fifo valid */
	if (!fifo->base || !fifo->length)
 800027e:	687b      	ldr	r3, [r7, #4]
 8000280:	68db      	ldr	r3, [r3, #12]
 8000282:	2b00      	cmp	r3, #0
 8000284:	d003      	beq.n	800028e <FIFO_dequeue+0x1a>
 8000286:	687b      	ldr	r3, [r7, #4]
 8000288:	691b      	ldr	r3, [r3, #16]
 800028a:	2b00      	cmp	r3, #0
 800028c:	d101      	bne.n	8000292 <FIFO_dequeue+0x1e>
		return FIFO_NULL;
 800028e:	2303      	movs	r3, #3
 8000290:	e02c      	b.n	80002ec <FIFO_dequeue+0x78>

	/* fifo empty */
	if (fifo->head == fifo->tail)
 8000292:	687b      	ldr	r3, [r7, #4]
 8000294:	685a      	ldr	r2, [r3, #4]
 8000296:	687b      	ldr	r3, [r7, #4]
 8000298:	689b      	ldr	r3, [r3, #8]
 800029a:	429a      	cmp	r2, r3
 800029c:	d101      	bne.n	80002a2 <FIFO_dequeue+0x2e>
		return FIFO_EMPTY;
 800029e:	2302      	movs	r3, #2
 80002a0:	e024      	b.n	80002ec <FIFO_dequeue+0x78>



	*item = *(fifo->head);
 80002a2:	687b      	ldr	r3, [r7, #4]
 80002a4:	685b      	ldr	r3, [r3, #4]
 80002a6:	681a      	ldr	r2, [r3, #0]
 80002a8:	683b      	ldr	r3, [r7, #0]
 80002aa:	601a      	str	r2, [r3, #0]
	*(fifo->head)=NULL;
 80002ac:	687b      	ldr	r3, [r7, #4]
 80002ae:	685b      	ldr	r3, [r3, #4]
 80002b0:	2200      	movs	r2, #0
 80002b2:	601a      	str	r2, [r3, #0]
	fifo->counter--;
 80002b4:	687b      	ldr	r3, [r7, #4]
 80002b6:	681b      	ldr	r3, [r3, #0]
 80002b8:	1e5a      	subs	r2, r3, #1
 80002ba:	687b      	ldr	r3, [r7, #4]
 80002bc:	601a      	str	r2, [r3, #0]

	/* circular dequeue */
	if (fifo->head == (((unsigned int)fifo->base + (4*fifo->length )) - 4 ))
 80002be:	687b      	ldr	r3, [r7, #4]
 80002c0:	685b      	ldr	r3, [r3, #4]
 80002c2:	687a      	ldr	r2, [r7, #4]
 80002c4:	68d2      	ldr	r2, [r2, #12]
 80002c6:	4611      	mov	r1, r2
 80002c8:	687a      	ldr	r2, [r7, #4]
 80002ca:	6912      	ldr	r2, [r2, #16]
 80002cc:	0092      	lsls	r2, r2, #2
 80002ce:	440a      	add	r2, r1
 80002d0:	3a04      	subs	r2, #4
 80002d2:	4293      	cmp	r3, r2
 80002d4:	d104      	bne.n	80002e0 <FIFO_dequeue+0x6c>
		fifo->head = fifo->base;
 80002d6:	687b      	ldr	r3, [r7, #4]
 80002d8:	68da      	ldr	r2, [r3, #12]
 80002da:	687b      	ldr	r3, [r7, #4]
 80002dc:	605a      	str	r2, [r3, #4]
 80002de:	e004      	b.n	80002ea <FIFO_dequeue+0x76>
	else
		fifo->head++;
 80002e0:	687b      	ldr	r3, [r7, #4]
 80002e2:	685b      	ldr	r3, [r3, #4]
 80002e4:	1d1a      	adds	r2, r3, #4
 80002e6:	687b      	ldr	r3, [r7, #4]
 80002e8:	605a      	str	r2, [r3, #4]

	return FIFO_NO_ERROR;
 80002ea:	2300      	movs	r3, #0
}
 80002ec:	4618      	mov	r0, r3
 80002ee:	370c      	adds	r7, #12
 80002f0:	46bd      	mov	sp, r7
 80002f2:	bc80      	pop	{r7}
 80002f4:	4770      	bx	lr
	...

080002f8 <PendSV_Handler>:
{
	//====================================
	//Save the Context of the Current Task
	//====================================
	//Get the Current Task "Current PSP from CPU register" as CPU Push
	OS_GET_PSP(OS_Control.CurrentTask->Current_PSP);
 80002f8:	4b6f      	ldr	r3, [pc, #444]	; (80004b8 <PendSV_Handler+0x1c0>)
 80002fa:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80002fe:	f3ef 8009 	mrs	r0, PSP
 8000302:	4602      	mov	r2, r0
 8000304:	615a      	str	r2, [r3, #20]

	//using this Current_PSP store from R4 to R11
	OS_Control.CurrentTask->Current_PSP-- ;
 8000306:	4b6c      	ldr	r3, [pc, #432]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000308:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800030c:	695a      	ldr	r2, [r3, #20]
 800030e:	3a04      	subs	r2, #4
 8000310:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r4 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000312:	4b69      	ldr	r3, [pc, #420]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000314:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000318:	695b      	ldr	r3, [r3, #20]
 800031a:	4622      	mov	r2, r4
 800031c:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 800031e:	4b66      	ldr	r3, [pc, #408]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000320:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000324:	695a      	ldr	r2, [r3, #20]
 8000326:	3a04      	subs	r2, #4
 8000328:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r5 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800032a:	4b63      	ldr	r3, [pc, #396]	; (80004b8 <PendSV_Handler+0x1c0>)
 800032c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000330:	695b      	ldr	r3, [r3, #20]
 8000332:	462a      	mov	r2, r5
 8000334:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 8000336:	4b60      	ldr	r3, [pc, #384]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000338:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800033c:	695a      	ldr	r2, [r3, #20]
 800033e:	3a04      	subs	r2, #4
 8000340:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r6 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000342:	4b5d      	ldr	r3, [pc, #372]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000344:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000348:	695b      	ldr	r3, [r3, #20]
 800034a:	4632      	mov	r2, r6
 800034c:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 800034e:	4b5a      	ldr	r3, [pc, #360]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000350:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000354:	695a      	ldr	r2, [r3, #20]
 8000356:	3a04      	subs	r2, #4
 8000358:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r7 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800035a:	4b57      	ldr	r3, [pc, #348]	; (80004b8 <PendSV_Handler+0x1c0>)
 800035c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000360:	695b      	ldr	r3, [r3, #20]
 8000362:	463a      	mov	r2, r7
 8000364:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 8000366:	4b54      	ldr	r3, [pc, #336]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000368:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800036c:	695a      	ldr	r2, [r3, #20]
 800036e:	3a04      	subs	r2, #4
 8000370:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r8 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000372:	4b51      	ldr	r3, [pc, #324]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000374:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000378:	695b      	ldr	r3, [r3, #20]
 800037a:	4642      	mov	r2, r8
 800037c:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 800037e:	4b4e      	ldr	r3, [pc, #312]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000380:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000384:	695a      	ldr	r2, [r3, #20]
 8000386:	3a04      	subs	r2, #4
 8000388:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r9 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800038a:	4b4b      	ldr	r3, [pc, #300]	; (80004b8 <PendSV_Handler+0x1c0>)
 800038c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000390:	695b      	ldr	r3, [r3, #20]
 8000392:	464a      	mov	r2, r9
 8000394:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 8000396:	4b48      	ldr	r3, [pc, #288]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000398:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800039c:	695a      	ldr	r2, [r3, #20]
 800039e:	3a04      	subs	r2, #4
 80003a0:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r10 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 80003a2:	4b45      	ldr	r3, [pc, #276]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003a4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80003a8:	695b      	ldr	r3, [r3, #20]
 80003aa:	4652      	mov	r2, sl
 80003ac:	601a      	str	r2, [r3, #0]
	OS_Control.CurrentTask->Current_PSP-- ;
 80003ae:	4b42      	ldr	r3, [pc, #264]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003b0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80003b4:	695a      	ldr	r2, [r3, #20]
 80003b6:	3a04      	subs	r2, #4
 80003b8:	615a      	str	r2, [r3, #20]
	__asm volatile("mov %0,r11 " : "=r" (*(OS_Control.CurrentTask->Current_PSP))  );
 80003ba:	4b3f      	ldr	r3, [pc, #252]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003bc:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80003c0:	695b      	ldr	r3, [r3, #20]
 80003c2:	465a      	mov	r2, fp
 80003c4:	601a      	str	r2, [r3, #0]
	 * already saved in Current_PSP
	 */
	//====================================
	//Restore the Context of the Next Task
	//====================================
	if (OS_Control.NextTask != NULL)
 80003c6:	4b3c      	ldr	r3, [pc, #240]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003c8:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 80003cc:	2b00      	cmp	r3, #0
 80003ce:	d009      	beq.n	80003e4 <PendSV_Handler+0xec>
	{
	OS_Control.CurrentTask = OS_Control.NextTask ;
 80003d0:	4b39      	ldr	r3, [pc, #228]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003d2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 80003d6:	4a38      	ldr	r2, [pc, #224]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003d8:	f8c2 31a0 	str.w	r3, [r2, #416]	; 0x1a0
	OS_Control.NextTask = NULL ;
 80003dc:	4b36      	ldr	r3, [pc, #216]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003de:	2200      	movs	r2, #0
 80003e0:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
	}
	__asm volatile("mov r11,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 80003e4:	4b34      	ldr	r3, [pc, #208]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003e6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80003ea:	695b      	ldr	r3, [r3, #20]
 80003ec:	681b      	ldr	r3, [r3, #0]
 80003ee:	469b      	mov	fp, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 80003f0:	4b31      	ldr	r3, [pc, #196]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003f2:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80003f6:	695a      	ldr	r2, [r3, #20]
 80003f8:	3204      	adds	r2, #4
 80003fa:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r10,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 80003fc:	4b2e      	ldr	r3, [pc, #184]	; (80004b8 <PendSV_Handler+0x1c0>)
 80003fe:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000402:	695b      	ldr	r3, [r3, #20]
 8000404:	681b      	ldr	r3, [r3, #0]
 8000406:	469a      	mov	sl, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000408:	4b2b      	ldr	r3, [pc, #172]	; (80004b8 <PendSV_Handler+0x1c0>)
 800040a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800040e:	695a      	ldr	r2, [r3, #20]
 8000410:	3204      	adds	r2, #4
 8000412:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r9,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000414:	4b28      	ldr	r3, [pc, #160]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000416:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800041a:	695b      	ldr	r3, [r3, #20]
 800041c:	681b      	ldr	r3, [r3, #0]
 800041e:	4699      	mov	r9, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000420:	4b25      	ldr	r3, [pc, #148]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000422:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000426:	695a      	ldr	r2, [r3, #20]
 8000428:	3204      	adds	r2, #4
 800042a:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r8,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800042c:	4b22      	ldr	r3, [pc, #136]	; (80004b8 <PendSV_Handler+0x1c0>)
 800042e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000432:	695b      	ldr	r3, [r3, #20]
 8000434:	681b      	ldr	r3, [r3, #0]
 8000436:	4698      	mov	r8, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000438:	4b1f      	ldr	r3, [pc, #124]	; (80004b8 <PendSV_Handler+0x1c0>)
 800043a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800043e:	695a      	ldr	r2, [r3, #20]
 8000440:	3204      	adds	r2, #4
 8000442:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r7,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000444:	4b1c      	ldr	r3, [pc, #112]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000446:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800044a:	695b      	ldr	r3, [r3, #20]
 800044c:	681b      	ldr	r3, [r3, #0]
 800044e:	461f      	mov	r7, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000450:	4b19      	ldr	r3, [pc, #100]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000452:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000456:	695a      	ldr	r2, [r3, #20]
 8000458:	3204      	adds	r2, #4
 800045a:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r6,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800045c:	4b16      	ldr	r3, [pc, #88]	; (80004b8 <PendSV_Handler+0x1c0>)
 800045e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000462:	695b      	ldr	r3, [r3, #20]
 8000464:	681b      	ldr	r3, [r3, #0]
 8000466:	461e      	mov	r6, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000468:	4b13      	ldr	r3, [pc, #76]	; (80004b8 <PendSV_Handler+0x1c0>)
 800046a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800046e:	695a      	ldr	r2, [r3, #20]
 8000470:	3204      	adds	r2, #4
 8000472:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r5,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 8000474:	4b10      	ldr	r3, [pc, #64]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000476:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800047a:	695b      	ldr	r3, [r3, #20]
 800047c:	681b      	ldr	r3, [r3, #0]
 800047e:	461d      	mov	r5, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000480:	4b0d      	ldr	r3, [pc, #52]	; (80004b8 <PendSV_Handler+0x1c0>)
 8000482:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000486:	695a      	ldr	r2, [r3, #20]
 8000488:	3204      	adds	r2, #4
 800048a:	615a      	str	r2, [r3, #20]
	__asm volatile("mov r4,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP))  );
 800048c:	4b0a      	ldr	r3, [pc, #40]	; (80004b8 <PendSV_Handler+0x1c0>)
 800048e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000492:	695b      	ldr	r3, [r3, #20]
 8000494:	681b      	ldr	r3, [r3, #0]
 8000496:	461c      	mov	r4, r3
	OS_Control.CurrentTask->Current_PSP++ ;
 8000498:	4b07      	ldr	r3, [pc, #28]	; (80004b8 <PendSV_Handler+0x1c0>)
 800049a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800049e:	695a      	ldr	r2, [r3, #20]
 80004a0:	3204      	adds	r2, #4
 80004a2:	615a      	str	r2, [r3, #20]
	//update PSP and exit
	OS_SET_PSP(OS_Control.CurrentTask->Current_PSP);
 80004a4:	4b04      	ldr	r3, [pc, #16]	; (80004b8 <PendSV_Handler+0x1c0>)
 80004a6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80004aa:	695b      	ldr	r3, [r3, #20]
 80004ac:	4618      	mov	r0, r3
 80004ae:	f380 8809 	msr	PSP, r0
	// return to next task
	__asm volatile("BX LR");
 80004b2:	4770      	bx	lr
}
 80004b4:	bf00      	nop
 80004b6:	bf00      	nop
 80004b8:	20000030 	.word	0x20000030

080004bc <bubbleSort>:
	return error ;
}


void bubbleSort()
{
 80004bc:	b480      	push	{r7}
 80004be:	b085      	sub	sp, #20
 80004c0:	af00      	add	r7, sp, #0
	unsigned int i, j , n;
	Task_Ref* temp ;
	n=OS_Control.NoOfActiveTasks ;
 80004c2:	4b21      	ldr	r3, [pc, #132]	; (8000548 <bubbleSort+0x8c>)
 80004c4:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 80004c8:	607b      	str	r3, [r7, #4]
	for (i = 0; i < n - 1; i++)
 80004ca:	2300      	movs	r3, #0
 80004cc:	60fb      	str	r3, [r7, #12]
 80004ce:	e030      	b.n	8000532 <bubbleSort+0x76>
		for (j = 0; j < n - i - 1; j++)
 80004d0:	2300      	movs	r3, #0
 80004d2:	60bb      	str	r3, [r7, #8]
 80004d4:	e023      	b.n	800051e <bubbleSort+0x62>
			if (OS_Control.OSTasks[j]->priority > OS_Control.OSTasks[j + 1]->priority)
 80004d6:	4a1c      	ldr	r2, [pc, #112]	; (8000548 <bubbleSort+0x8c>)
 80004d8:	68bb      	ldr	r3, [r7, #8]
 80004da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80004de:	791a      	ldrb	r2, [r3, #4]
 80004e0:	68bb      	ldr	r3, [r7, #8]
 80004e2:	3301      	adds	r3, #1
 80004e4:	4918      	ldr	r1, [pc, #96]	; (8000548 <bubbleSort+0x8c>)
 80004e6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80004ea:	791b      	ldrb	r3, [r3, #4]
 80004ec:	429a      	cmp	r2, r3
 80004ee:	d913      	bls.n	8000518 <bubbleSort+0x5c>
			{
				temp = OS_Control.OSTasks[j] ;
 80004f0:	4a15      	ldr	r2, [pc, #84]	; (8000548 <bubbleSort+0x8c>)
 80004f2:	68bb      	ldr	r3, [r7, #8]
 80004f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80004f8:	603b      	str	r3, [r7, #0]
				OS_Control.OSTasks[j] = OS_Control.OSTasks[j + 1 ] ;
 80004fa:	68bb      	ldr	r3, [r7, #8]
 80004fc:	3301      	adds	r3, #1
 80004fe:	4a12      	ldr	r2, [pc, #72]	; (8000548 <bubbleSort+0x8c>)
 8000500:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000504:	4910      	ldr	r1, [pc, #64]	; (8000548 <bubbleSort+0x8c>)
 8000506:	68bb      	ldr	r3, [r7, #8]
 8000508:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				OS_Control.OSTasks[j + 1] = temp ;
 800050c:	68bb      	ldr	r3, [r7, #8]
 800050e:	3301      	adds	r3, #1
 8000510:	490d      	ldr	r1, [pc, #52]	; (8000548 <bubbleSort+0x8c>)
 8000512:	683a      	ldr	r2, [r7, #0]
 8000514:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		for (j = 0; j < n - i - 1; j++)
 8000518:	68bb      	ldr	r3, [r7, #8]
 800051a:	3301      	adds	r3, #1
 800051c:	60bb      	str	r3, [r7, #8]
 800051e:	687a      	ldr	r2, [r7, #4]
 8000520:	68fb      	ldr	r3, [r7, #12]
 8000522:	1ad3      	subs	r3, r2, r3
 8000524:	3b01      	subs	r3, #1
 8000526:	68ba      	ldr	r2, [r7, #8]
 8000528:	429a      	cmp	r2, r3
 800052a:	d3d4      	bcc.n	80004d6 <bubbleSort+0x1a>
	for (i = 0; i < n - 1; i++)
 800052c:	68fb      	ldr	r3, [r7, #12]
 800052e:	3301      	adds	r3, #1
 8000530:	60fb      	str	r3, [r7, #12]
 8000532:	687b      	ldr	r3, [r7, #4]
 8000534:	3b01      	subs	r3, #1
 8000536:	68fa      	ldr	r2, [r7, #12]
 8000538:	429a      	cmp	r2, r3
 800053a:	d3c9      	bcc.n	80004d0 <bubbleSort+0x14>
			}
}
 800053c:	bf00      	nop
 800053e:	3714      	adds	r7, #20
 8000540:	46bd      	mov	sp, r7
 8000542:	bc80      	pop	{r7}
 8000544:	4770      	bx	lr
 8000546:	bf00      	nop
 8000548:	20000030 	.word	0x20000030

0800054c <MyRTOS_Update_Schadule_tables>:
* @Fn          - MyRTOS_Update_Schedule_tables
* @brief       - Updates the schedule tables in MyRTOS
* @retval      - The error code indicating the success or failure of the update process
*/
MY_RTOS_ErrorID MyRTOS_Update_Schadule_tables()
{
 800054c:	b580      	push	{r7, lr}
 800054e:	b086      	sub	sp, #24
 8000550:	af00      	add	r7, sp, #0
	MY_RTOS_ErrorID error=NO_ERROR;
 8000552:	2300      	movs	r3, #0
 8000554:	74fb      	strb	r3, [r7, #19]
	Task_Ref* temp =NULL ;
 8000556:	2300      	movs	r3, #0
 8000558:	607b      	str	r3, [r7, #4]
	Task_Ref* Ptask ;
	Task_Ref* PnextTask ;
	int i = 0 ;
 800055a:	2300      	movs	r3, #0
 800055c:	617b      	str	r3, [r7, #20]
	//1- bubble sort SchTable OS_Control priority high then low
	bubbleSort();
 800055e:	f7ff ffad 	bl	80004bc <bubbleSort>
	//2-free Ready Queue
	while(FIFO_dequeue(&Ready_QUEUE,&temp )!=FIFO_EMPTY);
 8000562:	bf00      	nop
 8000564:	1d3b      	adds	r3, r7, #4
 8000566:	4619      	mov	r1, r3
 8000568:	482e      	ldr	r0, [pc, #184]	; (8000624 <MyRTOS_Update_Schadule_tables+0xd8>)
 800056a:	f7ff fe83 	bl	8000274 <FIFO_dequeue>
 800056e:	4603      	mov	r3, r0
 8000570:	2b02      	cmp	r3, #2
 8000572:	d1f7      	bne.n	8000564 <MyRTOS_Update_Schadule_tables+0x18>
	//3- update ready queue
	while(i< OS_Control.NoOfActiveTasks)
 8000574:	e04b      	b.n	800060e <MyRTOS_Update_Schadule_tables+0xc2>
	{
		Ptask = OS_Control.OSTasks[i] ;
 8000576:	4a2c      	ldr	r2, [pc, #176]	; (8000628 <MyRTOS_Update_Schadule_tables+0xdc>)
 8000578:	697b      	ldr	r3, [r7, #20]
 800057a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800057e:	60fb      	str	r3, [r7, #12]
		PnextTask = OS_Control.OSTasks[i+1] ;
 8000580:	697b      	ldr	r3, [r7, #20]
 8000582:	3301      	adds	r3, #1
 8000584:	4a28      	ldr	r2, [pc, #160]	; (8000628 <MyRTOS_Update_Schadule_tables+0xdc>)
 8000586:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800058a:	60bb      	str	r3, [r7, #8]
		if (Ptask->TaskState != Suspend)
 800058c:	68fb      	ldr	r3, [r7, #12]
 800058e:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 8000592:	2b00      	cmp	r3, #0
 8000594:	d038      	beq.n	8000608 <MyRTOS_Update_Schadule_tables+0xbc>
		{
			//	if the Ptask priority > next task then hear 15<14
			if (Ptask->priority < PnextTask->priority )
 8000596:	68fb      	ldr	r3, [r7, #12]
 8000598:	791a      	ldrb	r2, [r3, #4]
 800059a:	68bb      	ldr	r3, [r7, #8]
 800059c:	791b      	ldrb	r3, [r3, #4]
 800059e:	429a      	cmp	r2, r3
 80005a0:	d208      	bcs.n	80005b4 <MyRTOS_Update_Schadule_tables+0x68>
			{
				FIFO_enqueue(&Ready_QUEUE, Ptask);
 80005a2:	68f9      	ldr	r1, [r7, #12]
 80005a4:	481f      	ldr	r0, [pc, #124]	; (8000624 <MyRTOS_Update_Schadule_tables+0xd8>)
 80005a6:	f7ff fe23 	bl	80001f0 <FIFO_enqueue>
				Ptask->TaskState = Ready ;
 80005aa:	68fb      	ldr	r3, [r7, #12]
 80005ac:	2203      	movs	r2, #3
 80005ae:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
				break ;
 80005b2:	e032      	b.n	800061a <MyRTOS_Update_Schadule_tables+0xce>
			}
			else if (Ptask->priority == PnextTask->priority)
 80005b4:	68fb      	ldr	r3, [r7, #12]
 80005b6:	791a      	ldrb	r2, [r3, #4]
 80005b8:	68bb      	ldr	r3, [r7, #8]
 80005ba:	791b      	ldrb	r3, [r3, #4]
 80005bc:	429a      	cmp	r2, r3
 80005be:	d108      	bne.n	80005d2 <MyRTOS_Update_Schadule_tables+0x86>
			{
				/*
				 * push Ptask to ready state
				 * again process
				 */
				FIFO_enqueue(&Ready_QUEUE, Ptask);
 80005c0:	68f9      	ldr	r1, [r7, #12]
 80005c2:	4818      	ldr	r0, [pc, #96]	; (8000624 <MyRTOS_Update_Schadule_tables+0xd8>)
 80005c4:	f7ff fe14 	bl	80001f0 <FIFO_enqueue>
				Ptask->TaskState = Ready ;
 80005c8:	68fb      	ldr	r3, [r7, #12]
 80005ca:	2203      	movs	r2, #3
 80005cc:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
 80005d0:	e01a      	b.n	8000608 <MyRTOS_Update_Schadule_tables+0xbc>
			}
			else if (Ptask->priority > PnextTask->priority)
 80005d2:	68fb      	ldr	r3, [r7, #12]
 80005d4:	791a      	ldrb	r2, [r3, #4]
 80005d6:	68bb      	ldr	r3, [r7, #8]
 80005d8:	791b      	ldrb	r3, [r3, #4]
 80005da:	429a      	cmp	r2, r3
 80005dc:	d914      	bls.n	8000608 <MyRTOS_Update_Schadule_tables+0xbc>
			{
				if((i+1)<OS_Control.NoOfActiveTasks)
 80005de:	697b      	ldr	r3, [r7, #20]
 80005e0:	3301      	adds	r3, #1
 80005e2:	461a      	mov	r2, r3
 80005e4:	4b10      	ldr	r3, [pc, #64]	; (8000628 <MyRTOS_Update_Schadule_tables+0xdc>)
 80005e6:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 80005ea:	429a      	cmp	r2, r3
 80005ec:	d203      	bcs.n	80005f6 <MyRTOS_Update_Schadule_tables+0xaa>
				{
					//Return error
					error=SO_Table_Sort_Error;
 80005ee:	2303      	movs	r3, #3
 80005f0:	74fb      	strb	r3, [r7, #19]
					return error;
 80005f2:	7cfb      	ldrb	r3, [r7, #19]
 80005f4:	e011      	b.n	800061a <MyRTOS_Update_Schadule_tables+0xce>
				}
				//MYRTOS_IdleTask
				FIFO_enqueue(&Ready_QUEUE, Ptask);
 80005f6:	68f9      	ldr	r1, [r7, #12]
 80005f8:	480a      	ldr	r0, [pc, #40]	; (8000624 <MyRTOS_Update_Schadule_tables+0xd8>)
 80005fa:	f7ff fdf9 	bl	80001f0 <FIFO_enqueue>
				Ptask->TaskState = Ready ;
 80005fe:	68fb      	ldr	r3, [r7, #12]
 8000600:	2203      	movs	r2, #3
 8000602:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
				break ;
 8000606:	e008      	b.n	800061a <MyRTOS_Update_Schadule_tables+0xce>
			}
		}
		i++ ;
 8000608:	697b      	ldr	r3, [r7, #20]
 800060a:	3301      	adds	r3, #1
 800060c:	617b      	str	r3, [r7, #20]
	while(i< OS_Control.NoOfActiveTasks)
 800060e:	4b06      	ldr	r3, [pc, #24]	; (8000628 <MyRTOS_Update_Schadule_tables+0xdc>)
 8000610:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 8000614:	697b      	ldr	r3, [r7, #20]
 8000616:	429a      	cmp	r2, r3
 8000618:	d8ad      	bhi.n	8000576 <MyRTOS_Update_Schadule_tables+0x2a>
	}
}
 800061a:	4618      	mov	r0, r3
 800061c:	3718      	adds	r7, #24
 800061e:	46bd      	mov	sp, r7
 8000620:	bd80      	pop	{r7, pc}
 8000622:	bf00      	nop
 8000624:	200001dc 	.word	0x200001dc
 8000628:	20000030 	.word	0x20000030

0800062c <Decide_whatNext>:
* @Fn          - Decide_whatNext
* @brief       - Makes decisions on the next task to execute based on the current state and priority in an RTOS
* @retval      - None
*/
void Decide_whatNext()
{
 800062c:	b580      	push	{r7, lr}
 800062e:	af00      	add	r7, sp, #0
	//if Ready Queue is empty && OS_Control->currentTask != suspend
	if (Ready_QUEUE.counter == 0 && OS_Control.CurrentTask->TaskState != Suspend)
 8000630:	4b24      	ldr	r3, [pc, #144]	; (80006c4 <Decide_whatNext+0x98>)
 8000632:	681b      	ldr	r3, [r3, #0]
 8000634:	2b00      	cmp	r3, #0
 8000636:	d11a      	bne.n	800066e <Decide_whatNext+0x42>
 8000638:	4b23      	ldr	r3, [pc, #140]	; (80006c8 <Decide_whatNext+0x9c>)
 800063a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800063e:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 8000642:	2b00      	cmp	r3, #0
 8000644:	d013      	beq.n	800066e <Decide_whatNext+0x42>
	{
		OS_Control.CurrentTask->TaskState = Running ;
 8000646:	4b20      	ldr	r3, [pc, #128]	; (80006c8 <Decide_whatNext+0x9c>)
 8000648:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800064c:	2201      	movs	r2, #1
 800064e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
		//add the current task again(round robin)
		FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
 8000652:	4b1d      	ldr	r3, [pc, #116]	; (80006c8 <Decide_whatNext+0x9c>)
 8000654:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000658:	4619      	mov	r1, r3
 800065a:	481a      	ldr	r0, [pc, #104]	; (80006c4 <Decide_whatNext+0x98>)
 800065c:	f7ff fdc8 	bl	80001f0 <FIFO_enqueue>
		OS_Control.NextTask = OS_Control.CurrentTask ;
 8000660:	4b19      	ldr	r3, [pc, #100]	; (80006c8 <Decide_whatNext+0x9c>)
 8000662:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000666:	4a18      	ldr	r2, [pc, #96]	; (80006c8 <Decide_whatNext+0x9c>)
 8000668:	f8c2 31a4 	str.w	r3, [r2, #420]	; 0x1a4
		{
			FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
			OS_Control.CurrentTask->TaskState = Ready ;
		}
	}
}
 800066c:	e027      	b.n	80006be <Decide_whatNext+0x92>
		FIFO_dequeue(&Ready_QUEUE, &OS_Control.NextTask);
 800066e:	4917      	ldr	r1, [pc, #92]	; (80006cc <Decide_whatNext+0xa0>)
 8000670:	4814      	ldr	r0, [pc, #80]	; (80006c4 <Decide_whatNext+0x98>)
 8000672:	f7ff fdff 	bl	8000274 <FIFO_dequeue>
		OS_Control.NextTask->TaskState = Running ;
 8000676:	4b14      	ldr	r3, [pc, #80]	; (80006c8 <Decide_whatNext+0x9c>)
 8000678:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800067c:	2201      	movs	r2, #1
 800067e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
		if ((OS_Control.CurrentTask->priority == OS_Control.NextTask->priority )&&(OS_Control.CurrentTask->TaskState != Suspend))
 8000682:	4b11      	ldr	r3, [pc, #68]	; (80006c8 <Decide_whatNext+0x9c>)
 8000684:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000688:	791a      	ldrb	r2, [r3, #4]
 800068a:	4b0f      	ldr	r3, [pc, #60]	; (80006c8 <Decide_whatNext+0x9c>)
 800068c:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8000690:	791b      	ldrb	r3, [r3, #4]
 8000692:	429a      	cmp	r2, r3
 8000694:	d113      	bne.n	80006be <Decide_whatNext+0x92>
 8000696:	4b0c      	ldr	r3, [pc, #48]	; (80006c8 <Decide_whatNext+0x9c>)
 8000698:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800069c:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 80006a0:	2b00      	cmp	r3, #0
 80006a2:	d00c      	beq.n	80006be <Decide_whatNext+0x92>
			FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
 80006a4:	4b08      	ldr	r3, [pc, #32]	; (80006c8 <Decide_whatNext+0x9c>)
 80006a6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80006aa:	4619      	mov	r1, r3
 80006ac:	4805      	ldr	r0, [pc, #20]	; (80006c4 <Decide_whatNext+0x98>)
 80006ae:	f7ff fd9f 	bl	80001f0 <FIFO_enqueue>
			OS_Control.CurrentTask->TaskState = Ready ;
 80006b2:	4b05      	ldr	r3, [pc, #20]	; (80006c8 <Decide_whatNext+0x9c>)
 80006b4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80006b8:	2203      	movs	r2, #3
 80006ba:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
}
 80006be:	bf00      	nop
 80006c0:	bd80      	pop	{r7, pc}
 80006c2:	bf00      	nop
 80006c4:	200001dc 	.word	0x200001dc
 80006c8:	20000030 	.word	0x20000030
 80006cc:	200001d4 	.word	0x200001d4

080006d0 <OS_SV>:
* @brief       - Handles the Supervisor Call (SV) interrupt in the OS context
* @param [in]  - Stack_Frame: Pointer to the stack frame containing the saved registers
* @retval      - None
*/
void OS_SV(int* Stack_Frame)
{
 80006d0:	b580      	push	{r7, lr}
 80006d2:	b084      	sub	sp, #16
 80006d4:	af00      	add	r7, sp, #0
 80006d6:	6078      	str	r0, [r7, #4]
	uint8_t SVC_Number;
	SVC_Number=*((uint8_t*)(((uint8_t*)Stack_Frame[6])-2));
 80006d8:	687b      	ldr	r3, [r7, #4]
 80006da:	3318      	adds	r3, #24
 80006dc:	681b      	ldr	r3, [r3, #0]
 80006de:	3b02      	subs	r3, #2
 80006e0:	781b      	ldrb	r3, [r3, #0]
 80006e2:	73fb      	strb	r3, [r7, #15]
	switch(SVC_Number)
 80006e4:	7bfb      	ldrb	r3, [r7, #15]
 80006e6:	2b03      	cmp	r3, #3
 80006e8:	d827      	bhi.n	800073a <OS_SV+0x6a>
 80006ea:	a201      	add	r2, pc, #4	; (adr r2, 80006f0 <OS_SV+0x20>)
 80006ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80006f0:	08000701 	.word	0x08000701
 80006f4:	08000701 	.word	0x08000701
 80006f8:	0800072f 	.word	0x0800072f
 80006fc:	08000735 	.word	0x08000735
	{
	case SVC_Activatetask:
	case SVC_terminateTask:
		//Update Scheduler table and ready queue
		MyRTOS_Update_Schadule_tables();
 8000700:	f7ff ff24 	bl	800054c <MyRTOS_Update_Schadule_tables>
		//OS is in Running State
		if (OS_Control.OSmodeID == OsRunning)
 8000704:	4b0f      	ldr	r3, [pc, #60]	; (8000744 <OS_SV+0x74>)
 8000706:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800070a:	2b01      	cmp	r3, #1
 800070c:	d114      	bne.n	8000738 <OS_SV+0x68>
		{
			if (strcmp(OS_Control.CurrentTask->TaskName,"idleTask") != 0)
 800070e:	4b0d      	ldr	r3, [pc, #52]	; (8000744 <OS_SV+0x74>)
 8000710:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8000714:	3318      	adds	r3, #24
 8000716:	490c      	ldr	r1, [pc, #48]	; (8000748 <OS_SV+0x78>)
 8000718:	4618      	mov	r0, r3
 800071a:	f7ff fd29 	bl	8000170 <strcmp>
 800071e:	4603      	mov	r3, r0
 8000720:	2b00      	cmp	r3, #0
 8000722:	d009      	beq.n	8000738 <OS_SV+0x68>
			{
				//Decide what Next
				Decide_whatNext();
 8000724:	f7ff ff82 	bl	800062c <Decide_whatNext>
				//trigger OS_pendSV (Switch Context/Restore)
				trigger_OS_PendSV();
 8000728:	f7ff fd40 	bl	80001ac <trigger_OS_PendSV>
			}
		}
		break;
 800072c:	e004      	b.n	8000738 <OS_SV+0x68>
	case SVC_TaskWaitingTime:
		//Update Scheduler table and ready queue
		MyRTOS_Update_Schadule_tables();
 800072e:	f7ff ff0d 	bl	800054c <MyRTOS_Update_Schadule_tables>
		break;
 8000732:	e002      	b.n	800073a <OS_SV+0x6a>
	case 3:

		break;
 8000734:	bf00      	nop
 8000736:	e000      	b.n	800073a <OS_SV+0x6a>
		break;
 8000738:	bf00      	nop
	}
}
 800073a:	bf00      	nop
 800073c:	3710      	adds	r7, #16
 800073e:	46bd      	mov	sp, r7
 8000740:	bd80      	pop	{r7, pc}
 8000742:	bf00      	nop
 8000744:	20000030 	.word	0x20000030
 8000748:	0800194c 	.word	0x0800194c

0800074c <MYRTOS_OS_SVC_Set>:
* @brief       - Sets the appropriate Supervisor Call (SVC) instruction based on the given SVC ID
* @param [in]  - ID: The SVC ID representing the desired SVC operation
* @retval      - None
*/
void MYRTOS_OS_SVC_Set(SVC_ID ID)
{
 800074c:	b480      	push	{r7}
 800074e:	b083      	sub	sp, #12
 8000750:	af00      	add	r7, sp, #0
 8000752:	4603      	mov	r3, r0
 8000754:	71fb      	strb	r3, [r7, #7]
	switch (ID)
 8000756:	79fb      	ldrb	r3, [r7, #7]
 8000758:	2b01      	cmp	r3, #1
 800075a:	d006      	beq.n	800076a <MYRTOS_OS_SVC_Set+0x1e>
 800075c:	2b02      	cmp	r3, #2
 800075e:	d006      	beq.n	800076e <MYRTOS_OS_SVC_Set+0x22>
 8000760:	2b00      	cmp	r3, #0
 8000762:	d000      	beq.n	8000766 <MYRTOS_OS_SVC_Set+0x1a>
		break;
	case SVC_TaskWaitingTime:
		__asm("svc #0x02");
		break;
	}
}
 8000764:	e005      	b.n	8000772 <MYRTOS_OS_SVC_Set+0x26>
		__asm("svc #0x00");
 8000766:	df00      	svc	0
		break;
 8000768:	e003      	b.n	8000772 <MYRTOS_OS_SVC_Set+0x26>
		__asm("svc #0x01");
 800076a:	df01      	svc	1
		break;
 800076c:	e001      	b.n	8000772 <MYRTOS_OS_SVC_Set+0x26>
		__asm("svc #0x02");
 800076e:	df02      	svc	2
		break;
 8000770:	bf00      	nop
}
 8000772:	bf00      	nop
 8000774:	370c      	adds	r7, #12
 8000776:	46bd      	mov	sp, r7
 8000778:	bc80      	pop	{r7}
 800077a:	4770      	bx	lr

0800077c <MYRTOS_Update_TasksWaitingTime>:
* @Fn          - MYRTOS_Update_TasksWaitingTime
* @brief       - Updates the waiting time of tasks in MyRTOS
* @retval      - None
*/
void MYRTOS_Update_TasksWaitingTime()
{
 800077c:	b580      	push	{r7, lr}
 800077e:	b082      	sub	sp, #8
 8000780:	af00      	add	r7, sp, #0
	for (int i =0; i < OS_Control.NoOfActiveTasks ; i++)
 8000782:	2300      	movs	r3, #0
 8000784:	607b      	str	r3, [r7, #4]
 8000786:	e031      	b.n	80007ec <MYRTOS_Update_TasksWaitingTime+0x70>
	{
		if (Suspend==OS_Control.OSTasks[i]->TaskState)
 8000788:	4a1d      	ldr	r2, [pc, #116]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 800078a:	687b      	ldr	r3, [r7, #4]
 800078c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000790:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 8000794:	2b00      	cmp	r3, #0
 8000796:	d126      	bne.n	80007e6 <MYRTOS_Update_TasksWaitingTime+0x6a>
		{
			if (enable==OS_Control.OSTasks[i]->Timing_Waiting.Blocking)
 8000798:	4a19      	ldr	r2, [pc, #100]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 800079a:	687b      	ldr	r3, [r7, #4]
 800079c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80007a0:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80007a4:	2b01      	cmp	r3, #1
 80007a6:	d11e      	bne.n	80007e6 <MYRTOS_Update_TasksWaitingTime+0x6a>
			{
				OS_Control.OSTasks[i]->Timing_Waiting.Ticks_Count-- ;
 80007a8:	4a15      	ldr	r2, [pc, #84]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 80007aa:	687b      	ldr	r3, [r7, #4]
 80007ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80007b0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80007b2:	3a01      	subs	r2, #1
 80007b4:	63da      	str	r2, [r3, #60]	; 0x3c
				if (OS_Control.OSTasks[i]->Timing_Waiting.Ticks_Count == 1)
 80007b6:	4a12      	ldr	r2, [pc, #72]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 80007b8:	687b      	ldr	r3, [r7, #4]
 80007ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80007be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80007c0:	2b01      	cmp	r3, #1
 80007c2:	d110      	bne.n	80007e6 <MYRTOS_Update_TasksWaitingTime+0x6a>
				{
					OS_Control.OSTasks[i]->Timing_Waiting.Blocking = disable ;
 80007c4:	4a0e      	ldr	r2, [pc, #56]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 80007c6:	687b      	ldr	r3, [r7, #4]
 80007c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80007cc:	2200      	movs	r2, #0
 80007ce:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
					OS_Control.OSTasks[i]->TaskState = Waiting ;
 80007d2:	4a0b      	ldr	r2, [pc, #44]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 80007d4:	687b      	ldr	r3, [r7, #4]
 80007d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80007da:	2202      	movs	r2, #2
 80007dc:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
					MYRTOS_OS_SVC_Set(SVC_TaskWaitingTime);
 80007e0:	2002      	movs	r0, #2
 80007e2:	f7ff ffb3 	bl	800074c <MYRTOS_OS_SVC_Set>
	for (int i =0; i < OS_Control.NoOfActiveTasks ; i++)
 80007e6:	687b      	ldr	r3, [r7, #4]
 80007e8:	3301      	adds	r3, #1
 80007ea:	607b      	str	r3, [r7, #4]
 80007ec:	4b04      	ldr	r3, [pc, #16]	; (8000800 <MYRTOS_Update_TasksWaitingTime+0x84>)
 80007ee:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 80007f2:	687b      	ldr	r3, [r7, #4]
 80007f4:	429a      	cmp	r2, r3
 80007f6:	d8c7      	bhi.n	8000788 <MYRTOS_Update_TasksWaitingTime+0xc>
				}
			}
		}
	}
}
 80007f8:	bf00      	nop
 80007fa:	3708      	adds	r7, #8
 80007fc:	46bd      	mov	sp, r7
 80007fe:	bd80      	pop	{r7, pc}
 8000800:	20000030 	.word	0x20000030

08000804 <Clock_INIT>:
 **************************************************************
 *************************Init Functions **********************
 **************************************************************
 */
void Clock_INIT(void)
{
 8000804:	b480      	push	{r7}
 8000806:	af00      	add	r7, sp, #0
    //set on the clock for PORTA
    RCC_GPIOA_CLK_EN();
 8000808:	4b1f      	ldr	r3, [pc, #124]	; (8000888 <Clock_INIT+0x84>)
 800080a:	699b      	ldr	r3, [r3, #24]
 800080c:	4a1e      	ldr	r2, [pc, #120]	; (8000888 <Clock_INIT+0x84>)
 800080e:	f043 0304 	orr.w	r3, r3, #4
 8000812:	6193      	str	r3, [r2, #24]
    //set on the clock for PORTB
    RCC_GPIOB_CLK_EN();
 8000814:	4b1c      	ldr	r3, [pc, #112]	; (8000888 <Clock_INIT+0x84>)
 8000816:	699b      	ldr	r3, [r3, #24]
 8000818:	4a1b      	ldr	r2, [pc, #108]	; (8000888 <Clock_INIT+0x84>)
 800081a:	f043 0308 	orr.w	r3, r3, #8
 800081e:	6193      	str	r3, [r2, #24]
    //set on the clock for AFIO
    RCC_GPIOC_CLK_EN();
 8000820:	4b19      	ldr	r3, [pc, #100]	; (8000888 <Clock_INIT+0x84>)
 8000822:	699b      	ldr	r3, [r3, #24]
 8000824:	4a18      	ldr	r2, [pc, #96]	; (8000888 <Clock_INIT+0x84>)
 8000826:	f043 0310 	orr.w	r3, r3, #16
 800082a:	6193      	str	r3, [r2, #24]
    RCC_AFIO_CLK_EN();
 800082c:	4b16      	ldr	r3, [pc, #88]	; (8000888 <Clock_INIT+0x84>)
 800082e:	699b      	ldr	r3, [r3, #24]
 8000830:	4a15      	ldr	r2, [pc, #84]	; (8000888 <Clock_INIT+0x84>)
 8000832:	f043 0301 	orr.w	r3, r3, #1
 8000836:	6193      	str	r3, [r2, #24]
    RCC_TIM2_CLK_Enable();
 8000838:	4b13      	ldr	r3, [pc, #76]	; (8000888 <Clock_INIT+0x84>)
 800083a:	69db      	ldr	r3, [r3, #28]
 800083c:	4a12      	ldr	r2, [pc, #72]	; (8000888 <Clock_INIT+0x84>)
 800083e:	f043 0301 	orr.w	r3, r3, #1
 8000842:	61d3      	str	r3, [r2, #28]
    RCC_TIM3_CLK_Enable();
 8000844:	4b10      	ldr	r3, [pc, #64]	; (8000888 <Clock_INIT+0x84>)
 8000846:	69db      	ldr	r3, [r3, #28]
 8000848:	4a0f      	ldr	r2, [pc, #60]	; (8000888 <Clock_INIT+0x84>)
 800084a:	f043 0302 	orr.w	r3, r3, #2
 800084e:	61d3      	str	r3, [r2, #28]
    RCC_TIM4_CLK_Enable();
 8000850:	4b0d      	ldr	r3, [pc, #52]	; (8000888 <Clock_INIT+0x84>)
 8000852:	69db      	ldr	r3, [r3, #28]
 8000854:	4a0c      	ldr	r2, [pc, #48]	; (8000888 <Clock_INIT+0x84>)
 8000856:	f043 0304 	orr.w	r3, r3, #4
 800085a:	61d3      	str	r3, [r2, #28]
    RCC_ADC1_CLK_Enable();
 800085c:	4b0a      	ldr	r3, [pc, #40]	; (8000888 <Clock_INIT+0x84>)
 800085e:	699b      	ldr	r3, [r3, #24]
 8000860:	4a09      	ldr	r2, [pc, #36]	; (8000888 <Clock_INIT+0x84>)
 8000862:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000866:	6193      	str	r3, [r2, #24]
    RCC_USART1_CLK_Enable();
 8000868:	4b07      	ldr	r3, [pc, #28]	; (8000888 <Clock_INIT+0x84>)
 800086a:	699b      	ldr	r3, [r3, #24]
 800086c:	4a06      	ldr	r2, [pc, #24]	; (8000888 <Clock_INIT+0x84>)
 800086e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000872:	6193      	str	r3, [r2, #24]
    RCC_CAN_CLK_Enable();
 8000874:	4b04      	ldr	r3, [pc, #16]	; (8000888 <Clock_INIT+0x84>)
 8000876:	69db      	ldr	r3, [r3, #28]
 8000878:	4a03      	ldr	r2, [pc, #12]	; (8000888 <Clock_INIT+0x84>)
 800087a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800087e:	61d3      	str	r3, [r2, #28]
}
 8000880:	bf00      	nop
 8000882:	46bd      	mov	sp, r7
 8000884:	bc80      	pop	{r7}
 8000886:	4770      	bx	lr
 8000888:	40021000 	.word	0x40021000

0800088c <GPIO_Init>:

void GPIO_Init(void)
{
 800088c:	b580      	push	{r7, lr}
 800088e:	b082      	sub	sp, #8
 8000890:	af00      	add	r7, sp, #0
	GPIO_Pinconfig_t PIN;
	PIN.GPIO_MODE=GPIO_MODE_OUTPUT_OD;
 8000892:	2305      	movs	r3, #5
 8000894:	71bb      	strb	r3, [r7, #6]
	PIN.GPIO_OUTPUT_Speed=GPIO_speed_2M;
 8000896:	2302      	movs	r3, #2
 8000898:	71fb      	strb	r3, [r7, #7]
	PIN.pinNumber=GPIO_PIN_13;
 800089a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800089e:	80bb      	strh	r3, [r7, #4]
	MCAL_GPIO_Init(GPIOC, &PIN);
 80008a0:	1d3b      	adds	r3, r7, #4
 80008a2:	4619      	mov	r1, r3
 80008a4:	4803      	ldr	r0, [pc, #12]	; (80008b4 <GPIO_Init+0x28>)
 80008a6:	f000 ff8a 	bl	80017be <MCAL_GPIO_Init>
}
 80008aa:	bf00      	nop
 80008ac:	3708      	adds	r7, #8
 80008ae:	46bd      	mov	sp, r7
 80008b0:	bd80      	pop	{r7, pc}
 80008b2:	bf00      	nop
 80008b4:	40011000 	.word	0x40011000

080008b8 <MCAL_CAN_FIFO_0_Receive_Callback>:
 **************************************************************
 *************************Callback*****************************
 **************************************************************
 */
void MCAL_CAN_FIFO_0_Receive_Callback(void)
{
 80008b8:	b580      	push	{r7, lr}
 80008ba:	af00      	add	r7, sp, #0
	while(1)
	{
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
 80008bc:	2200      	movs	r2, #0
 80008be:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80008c2:	4809      	ldr	r0, [pc, #36]	; (80008e8 <MCAL_CAN_FIFO_0_Receive_Callback+0x30>)
 80008c4:	f000 fffa 	bl	80018bc <MCAL_GPIO_WritePin>
		delay_ms(1000);
 80008c8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80008cc:	f000 f8d8 	bl	8000a80 <delay_ms>
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
 80008d0:	2201      	movs	r2, #1
 80008d2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80008d6:	4804      	ldr	r0, [pc, #16]	; (80008e8 <MCAL_CAN_FIFO_0_Receive_Callback+0x30>)
 80008d8:	f000 fff0 	bl	80018bc <MCAL_GPIO_WritePin>
		delay_ms(1000);
 80008dc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80008e0:	f000 f8ce 	bl	8000a80 <delay_ms>
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
 80008e4:	e7ea      	b.n	80008bc <MCAL_CAN_FIFO_0_Receive_Callback+0x4>
 80008e6:	bf00      	nop
 80008e8:	40011000 	.word	0x40011000

080008ec <Callback>:
	}
}
void Callback(void)
{
 80008ec:	b580      	push	{r7, lr}
 80008ee:	af00      	add	r7, sp, #0
	while(1)
	{
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
 80008f0:	2200      	movs	r2, #0
 80008f2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80008f6:	4808      	ldr	r0, [pc, #32]	; (8000918 <Callback+0x2c>)
 80008f8:	f000 ffe0 	bl	80018bc <MCAL_GPIO_WritePin>
		delay_ms(100);
 80008fc:	2064      	movs	r0, #100	; 0x64
 80008fe:	f000 f8bf 	bl	8000a80 <delay_ms>
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
 8000902:	2201      	movs	r2, #1
 8000904:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000908:	4803      	ldr	r0, [pc, #12]	; (8000918 <Callback+0x2c>)
 800090a:	f000 ffd7 	bl	80018bc <MCAL_GPIO_WritePin>
		delay_ms(100);
 800090e:	2064      	movs	r0, #100	; 0x64
 8000910:	f000 f8b6 	bl	8000a80 <delay_ms>
		MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
 8000914:	e7ec      	b.n	80008f0 <Callback+0x4>
 8000916:	bf00      	nop
 8000918:	40011000 	.word	0x40011000

0800091c <main>:
 **************************************************************
 *************************Main *********************************
 **************************************************************
 */
int main(void)
{
 800091c:	b580      	push	{r7, lr}
 800091e:	b08e      	sub	sp, #56	; 0x38
 8000920:	af00      	add	r7, sp, #0
	//Init
    Clock_INIT();
 8000922:	f7ff ff6f 	bl	8000804 <Clock_INIT>
    GPIO_Init();
 8000926:	f7ff ffb1 	bl	800088c <GPIO_Init>
    // Get CAN Mode
    mode=MCAL_CAN_Get_Mode();
 800092a:	f000 fdb5 	bl	8001498 <MCAL_CAN_Get_Mode>
 800092e:	4603      	mov	r3, r0
 8000930:	461a      	mov	r2, r3
 8000932:	4b34      	ldr	r3, [pc, #208]	; (8000a04 <main+0xe8>)
 8000934:	701a      	strb	r2, [r3, #0]
    //TX Information Message
    Message_Info.DLC=5;
 8000936:	4b34      	ldr	r3, [pc, #208]	; (8000a08 <main+0xec>)
 8000938:	2205      	movs	r2, #5
 800093a:	60da      	str	r2, [r3, #12]
    Message_Info.IDE=CAN_IDE_Standard;
 800093c:	4b32      	ldr	r3, [pc, #200]	; (8000a08 <main+0xec>)
 800093e:	2200      	movs	r2, #0
 8000940:	721a      	strb	r2, [r3, #8]
    Message_Info.RTR=CAN_RTR_Data_Frame;
 8000942:	4b31      	ldr	r3, [pc, #196]	; (8000a08 <main+0xec>)
 8000944:	2200      	movs	r2, #0
 8000946:	725a      	strb	r2, [r3, #9]
    Message_Info.Std_ID=0X7FF;
 8000948:	4b2f      	ldr	r3, [pc, #188]	; (8000a08 <main+0xec>)
 800094a:	f240 72ff 	movw	r2, #2047	; 0x7ff
 800094e:	605a      	str	r2, [r3, #4]
    //Configuration CAN
    CAN_Config_t Can_Config ;
    Can_Config.Mode=CAN_MODE_Loop_back_Silent;
 8000950:	2302      	movs	r3, #2
 8000952:	61bb      	str	r3, [r7, #24]
    Can_Config.BaudRate=CAN_BaudRate_800;
 8000954:	2301      	movs	r3, #1
 8000956:	83bb      	strh	r3, [r7, #28]
    Can_Config.AutoBusOff=CAN_AutoBusOff_Disable;
 8000958:	2300      	movs	r3, #0
 800095a:	77bb      	strb	r3, [r7, #30]
    Can_Config.AutoRetransmission=CAN_AutoRetransmission_Disable;
 800095c:	2300      	movs	r3, #0
 800095e:	77fb      	strb	r3, [r7, #31]
	Can_Config.Fifo_Locked=CAN_Fifo_Locked_Enable;
 8000960:	2301      	movs	r3, #1
 8000962:	f887 3020 	strb.w	r3, [r7, #32]
	Can_Config.RX0_IRQ_EN=CAN_RX0_IRQ_EN_Enable;
 8000966:	2301      	movs	r3, #1
 8000968:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	Can_Config.RX1_IRQ_EN=CAN_RX1_IRQ_EN_Disable;
 800096c:	2300      	movs	r3, #0
 800096e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	Can_Config.SCE_IRQ_EN=CAN_SCE_IRQ_EN_Disable;
 8000972:	2300      	movs	r3, #0
 8000974:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
	Can_Config.TX_IRQ_EN=CAN_TX_IRQ_EN_Disable;
 8000978:	2300      	movs	r3, #0
 800097a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	Can_Config.P_TX_IRQ=NULL;
 800097e:	2300      	movs	r3, #0
 8000980:	62bb      	str	r3, [r7, #40]	; 0x28
	Can_Config.P_RX0_IRQ=Callback;
 8000982:	4b22      	ldr	r3, [pc, #136]	; (8000a0c <main+0xf0>)
 8000984:	62fb      	str	r3, [r7, #44]	; 0x2c
	MCAL_CAN_Init(&Can_Config);
 8000986:	f107 0318 	add.w	r3, r7, #24
 800098a:	4618      	mov	r0, r3
 800098c:	f000 f89e 	bl	8000acc <MCAL_CAN_Init>
	// Get CAN Mode
	mode=MCAL_CAN_Get_Mode();
 8000990:	f000 fd82 	bl	8001498 <MCAL_CAN_Get_Mode>
 8000994:	4603      	mov	r3, r0
 8000996:	461a      	mov	r2, r3
 8000998:	4b1a      	ldr	r3, [pc, #104]	; (8000a04 <main+0xe8>)
 800099a:	701a      	strb	r2, [r3, #0]
	//Configuration Filter Bank 0
	CAN_Filter_Config_t Filter_Config;
	Filter_Config.Filter_Bank=CAN_Filter_Bank_0;
 800099c:	2300      	movs	r3, #0
 800099e:	60fb      	str	r3, [r7, #12]
	Filter_Config.Filter_FIFO_Assignment=CAN_Filter_FIFO_Assignment_FIFO0;
 80009a0:	2300      	movs	r3, #0
 80009a2:	60bb      	str	r3, [r7, #8]
	Filter_Config.Filter_ID=0XFFE0FFE8;
 80009a4:	4b1a      	ldr	r3, [pc, #104]	; (8000a10 <main+0xf4>)
 80009a6:	603b      	str	r3, [r7, #0]
	Filter_Config.Filter_Mask_ID=0X1FF01FF8;
 80009a8:	4b1a      	ldr	r3, [pc, #104]	; (8000a14 <main+0xf8>)
 80009aa:	607b      	str	r3, [r7, #4]
	Filter_Config.Filter_Mode=CAN_Filter_Mode_List;
 80009ac:	2301      	movs	r3, #1
 80009ae:	613b      	str	r3, [r7, #16]
	Filter_Config.Filter_Scale=CAN_Filter_Scale_16;
 80009b0:	2300      	movs	r3, #0
 80009b2:	617b      	str	r3, [r7, #20]
	MCAL_CAN_Config_Filter(&Filter_Config);
 80009b4:	463b      	mov	r3, r7
 80009b6:	4618      	mov	r0, r3
 80009b8:	f000 fab8 	bl	8000f2c <MCAL_CAN_Config_Filter>
	//Configuration Filter Bank 1
	Filter_Config.Filter_Bank=CAN_Filter_Bank_1;
 80009bc:	2301      	movs	r3, #1
 80009be:	60fb      	str	r3, [r7, #12]
	Filter_Config.Filter_FIFO_Assignment=CAN_Filter_FIFO_Assignment_FIFO1;
 80009c0:	2301      	movs	r3, #1
 80009c2:	60bb      	str	r3, [r7, #8]
	Filter_Config.Filter_ID=0X1FE01FE8;
 80009c4:	4b14      	ldr	r3, [pc, #80]	; (8000a18 <main+0xfc>)
 80009c6:	603b      	str	r3, [r7, #0]
	Filter_Config.Filter_Mask_ID=0X1FF01FF8;
 80009c8:	4b12      	ldr	r3, [pc, #72]	; (8000a14 <main+0xf8>)
 80009ca:	607b      	str	r3, [r7, #4]
	Filter_Config.Filter_Mode=CAN_Filter_Mode_List;
 80009cc:	2301      	movs	r3, #1
 80009ce:	613b      	str	r3, [r7, #16]
	Filter_Config.Filter_Scale=CAN_Filter_Scale_16;
 80009d0:	2300      	movs	r3, #0
 80009d2:	617b      	str	r3, [r7, #20]
	MCAL_CAN_Config_Filter(&Filter_Config);
 80009d4:	463b      	mov	r3, r7
 80009d6:	4618      	mov	r0, r3
 80009d8:	f000 faa8 	bl	8000f2c <MCAL_CAN_Config_Filter>
	//Start CAN
	MCAL_CAN_Start();
 80009dc:	f000 fbd6 	bl	800118c <MCAL_CAN_Start>
	// Get CAN Mode
	mode=MCAL_CAN_Get_Mode();
 80009e0:	f000 fd5a 	bl	8001498 <MCAL_CAN_Get_Mode>
 80009e4:	4603      	mov	r3, r0
 80009e6:	461a      	mov	r2, r3
 80009e8:	4b06      	ldr	r3, [pc, #24]	; (8000a04 <main+0xe8>)
 80009ea:	701a      	strb	r2, [r3, #0]
	//Transmit Message
	MCAL_CAN_Add_TX_Message(&Message_Info,Data,&pMailbox);
 80009ec:	4a0b      	ldr	r2, [pc, #44]	; (8000a1c <main+0x100>)
 80009ee:	490c      	ldr	r1, [pc, #48]	; (8000a20 <main+0x104>)
 80009f0:	4805      	ldr	r0, [pc, #20]	; (8000a08 <main+0xec>)
 80009f2:	f000 fc0b 	bl	800120c <MCAL_CAN_Add_TX_Message>
	//Receive Message
	MCAL_CAN_Receive_Message(&RX_Message_Info,Data1);
 80009f6:	490b      	ldr	r1, [pc, #44]	; (8000a24 <main+0x108>)
 80009f8:	480b      	ldr	r0, [pc, #44]	; (8000a28 <main+0x10c>)
 80009fa:	f000 fcd1 	bl	80013a0 <MCAL_CAN_Receive_Message>
	//CAN Sleep
	MCAL_CAN_Request_Sleep();
 80009fe:	f000 fd3d 	bl	800147c <MCAL_CAN_Request_Sleep>
    while(1)
 8000a02:	e7fe      	b.n	8000a02 <main+0xe6>
 8000a04:	200003d8 	.word	0x200003d8
 8000a08:	200003c8 	.word	0x200003c8
 8000a0c:	080008ed 	.word	0x080008ed
 8000a10:	ffe0ffe8 	.word	0xffe0ffe8
 8000a14:	1ff01ff8 	.word	0x1ff01ff8
 8000a18:	1fe01fe8 	.word	0x1fe01fe8
 8000a1c:	200003c4 	.word	0x200003c4
 8000a20:	20000000 	.word	0x20000000
 8000a24:	20000024 	.word	0x20000024
 8000a28:	200003dc 	.word	0x200003dc

08000a2c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000a2c:	480d      	ldr	r0, [pc, #52]	; (8000a64 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000a2e:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 8000a30:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000a34:	480c      	ldr	r0, [pc, #48]	; (8000a68 <LoopForever+0x6>)
  ldr r1, =_edata
 8000a36:	490d      	ldr	r1, [pc, #52]	; (8000a6c <LoopForever+0xa>)
  ldr r2, =_sidata
 8000a38:	4a0d      	ldr	r2, [pc, #52]	; (8000a70 <LoopForever+0xe>)
  movs r3, #0
 8000a3a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000a3c:	e002      	b.n	8000a44 <LoopCopyDataInit>

08000a3e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000a3e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000a40:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000a42:	3304      	adds	r3, #4

08000a44 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000a44:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000a46:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000a48:	d3f9      	bcc.n	8000a3e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000a4a:	4a0a      	ldr	r2, [pc, #40]	; (8000a74 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000a4c:	4c0a      	ldr	r4, [pc, #40]	; (8000a78 <LoopForever+0x16>)
  movs r3, #0
 8000a4e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000a50:	e001      	b.n	8000a56 <LoopFillZerobss>

08000a52 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000a52:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000a54:	3204      	adds	r2, #4

08000a56 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000a56:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000a58:	d3fb      	bcc.n	8000a52 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8000a5a:	f000 ff47 	bl	80018ec <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000a5e:	f7ff ff5d 	bl	800091c <main>

08000a62 <LoopForever>:

LoopForever:
    b LoopForever
 8000a62:	e7fe      	b.n	8000a62 <LoopForever>
  ldr   r0, =_estack
 8000a64:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8000a68:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000a6c:	20000008 	.word	0x20000008
  ldr r2, =_sidata
 8000a70:	08001960 	.word	0x08001960
  ldr r2, =_sbss
 8000a74:	20000008 	.word	0x20000008
  ldr r4, =_ebss
 8000a78:	2000040c 	.word	0x2000040c

08000a7c <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000a7c:	e7fe      	b.n	8000a7c <ADC1_2_IRQHandler>
	...

08000a80 <delay_ms>:

#include "delay.h"


void delay_ms(int ms)
{
 8000a80:	b480      	push	{r7}
 8000a82:	b083      	sub	sp, #12
 8000a84:	af00      	add	r7, sp, #0
 8000a86:	6078      	str	r0, [r7, #4]
	// timer2 work at 8 MHZ set psc 7999 ( each increment take 1ms )
	TIM4->PSC=7999;
 8000a88:	4b0f      	ldr	r3, [pc, #60]	; (8000ac8 <delay_ms+0x48>)
 8000a8a:	f641 723f 	movw	r2, #7999	; 0x1f3f
 8000a8e:	629a      	str	r2, [r3, #40]	; 0x28
	// timer count at ms-1
	TIM4->ARR=ms-1;
 8000a90:	687b      	ldr	r3, [r7, #4]
 8000a92:	1e5a      	subs	r2, r3, #1
 8000a94:	4b0c      	ldr	r3, [pc, #48]	; (8000ac8 <delay_ms+0x48>)
 8000a96:	62da      	str	r2, [r3, #44]	; 0x2c
	// enable counter
	TIM4->CR1 |=1<<0;
 8000a98:	4b0b      	ldr	r3, [pc, #44]	; (8000ac8 <delay_ms+0x48>)
 8000a9a:	681b      	ldr	r3, [r3, #0]
 8000a9c:	4a0a      	ldr	r2, [pc, #40]	; (8000ac8 <delay_ms+0x48>)
 8000a9e:	f043 0301 	orr.w	r3, r3, #1
 8000aa2:	6013      	str	r3, [r2, #0]
	// wait until counter reached compared register
	while(!(TIM4->SR & 1<<0));
 8000aa4:	bf00      	nop
 8000aa6:	4b08      	ldr	r3, [pc, #32]	; (8000ac8 <delay_ms+0x48>)
 8000aa8:	691b      	ldr	r3, [r3, #16]
 8000aaa:	f003 0301 	and.w	r3, r3, #1
 8000aae:	2b00      	cmp	r3, #0
 8000ab0:	d0f9      	beq.n	8000aa6 <delay_ms+0x26>
	// clear flag
	TIM4->SR=0;
 8000ab2:	4b05      	ldr	r3, [pc, #20]	; (8000ac8 <delay_ms+0x48>)
 8000ab4:	2200      	movs	r2, #0
 8000ab6:	611a      	str	r2, [r3, #16]
	// disable counter
	TIM4->CR1 =0;
 8000ab8:	4b03      	ldr	r3, [pc, #12]	; (8000ac8 <delay_ms+0x48>)
 8000aba:	2200      	movs	r2, #0
 8000abc:	601a      	str	r2, [r3, #0]
}
 8000abe:	bf00      	nop
 8000ac0:	370c      	adds	r7, #12
 8000ac2:	46bd      	mov	sp, r7
 8000ac4:	bc80      	pop	{r7}
 8000ac6:	4770      	bx	lr
 8000ac8:	40000800 	.word	0x40000800

08000acc <MCAL_CAN_Init>:
* 					 take a pointers to function (this function calling at interrupt)
* @retval 			-Can_Status_t: status of Can hardware (CAN_OK,CAN_ERROR,...)
* Note				-at using MCAL_CAN_Init after MCAL_CAN_DeInit must Enable RCC Clock for can
*/
Can_Status_t MCAL_CAN_Init(CAN_Config_t* Can_Config)
{
 8000acc:	b5b0      	push	{r4, r5, r7, lr}
 8000ace:	b084      	sub	sp, #16
 8000ad0:	af00      	add	r7, sp, #0
 8000ad2:	6078      	str	r0, [r7, #4]
	Can_Status_t status;
	//Check Message_Info pointer
	if(Can_Config==NULL)
 8000ad4:	687b      	ldr	r3, [r7, #4]
 8000ad6:	2b00      	cmp	r3, #0
 8000ad8:	d103      	bne.n	8000ae2 <MCAL_CAN_Init+0x16>
	{
		status=CAN_ERROR;
 8000ada:	2301      	movs	r3, #1
 8000adc:	73fb      	strb	r3, [r7, #15]
		return status;
 8000ade:	7bfb      	ldrb	r3, [r7, #15]
 8000ae0:	e217      	b.n	8000f12 <MCAL_CAN_Init+0x446>
	}
	//Software sets this bit to request the CAN hardware to enter initialization mode.
	CAN_MCR &=~(1<<1);
 8000ae2:	4b98      	ldr	r3, [pc, #608]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ae4:	681b      	ldr	r3, [r3, #0]
 8000ae6:	4a97      	ldr	r2, [pc, #604]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ae8:	f023 0302 	bic.w	r3, r3, #2
 8000aec:	6013      	str	r3, [r2, #0]
	CAN_MCR |=(1<<0);
 8000aee:	4b95      	ldr	r3, [pc, #596]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	4a94      	ldr	r2, [pc, #592]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000af4:	f043 0301 	orr.w	r3, r3, #1
 8000af8:	6013      	str	r3, [r2, #0]
	//CAN bit timing register (baud Rate)
	CAN_BTR=0X0000000;
 8000afa:	4b93      	ldr	r3, [pc, #588]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000afc:	2200      	movs	r2, #0
 8000afe:	601a      	str	r2, [r3, #0]
	switch (Can_Config->BaudRate)
 8000b00:	687b      	ldr	r3, [r7, #4]
 8000b02:	889b      	ldrh	r3, [r3, #4]
 8000b04:	2b06      	cmp	r3, #6
 8000b06:	d84a      	bhi.n	8000b9e <MCAL_CAN_Init+0xd2>
 8000b08:	a201      	add	r2, pc, #4	; (adr r2, 8000b10 <MCAL_CAN_Init+0x44>)
 8000b0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000b0e:	bf00      	nop
 8000b10:	08000b2d 	.word	0x08000b2d
 8000b14:	08000b3b 	.word	0x08000b3b
 8000b18:	08000b49 	.word	0x08000b49
 8000b1c:	08000b57 	.word	0x08000b57
 8000b20:	08000b69 	.word	0x08000b69
 8000b24:	08000b7b 	.word	0x08000b7b
 8000b28:	08000b8d 	.word	0x08000b8d
	{
		case CAN_BaudRate_1000:
			CAN_BTR |=0x00050000;
 8000b2c:	4b86      	ldr	r3, [pc, #536]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b2e:	681b      	ldr	r3, [r3, #0]
 8000b30:	4a85      	ldr	r2, [pc, #532]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b32:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 8000b36:	6013      	str	r3, [r2, #0]
			break;
 8000b38:	e034      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_800:
			CAN_BTR |=0x00070000;
 8000b3a:	4b83      	ldr	r3, [pc, #524]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b3c:	681b      	ldr	r3, [r3, #0]
 8000b3e:	4a82      	ldr	r2, [pc, #520]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b40:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 8000b44:	6013      	str	r3, [r2, #0]
			break;
 8000b46:	e02d      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_500:
			CAN_BTR |=0x001C0000;
 8000b48:	4b7f      	ldr	r3, [pc, #508]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	4a7e      	ldr	r2, [pc, #504]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b4e:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8000b52:	6013      	str	r3, [r2, #0]
			break;
 8000b54:	e026      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_250:
			CAN_BTR |=0x001C0001;
 8000b56:	4b7c      	ldr	r3, [pc, #496]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b58:	681b      	ldr	r3, [r3, #0]
 8000b5a:	4a7b      	ldr	r2, [pc, #492]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b5c:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8000b60:	f043 0301 	orr.w	r3, r3, #1
 8000b64:	6013      	str	r3, [r2, #0]
			break;
 8000b66:	e01d      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_125:
			CAN_BTR |=0x001C0003;
 8000b68:	4b77      	ldr	r3, [pc, #476]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b6a:	681b      	ldr	r3, [r3, #0]
 8000b6c:	4a76      	ldr	r2, [pc, #472]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b6e:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8000b72:	f043 0303 	orr.w	r3, r3, #3
 8000b76:	6013      	str	r3, [r2, #0]
			break;
 8000b78:	e014      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_100:
			CAN_BTR |=0x001C0004;
 8000b7a:	4b73      	ldr	r3, [pc, #460]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b7c:	681b      	ldr	r3, [r3, #0]
 8000b7e:	4a72      	ldr	r2, [pc, #456]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b80:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8000b84:	f043 0304 	orr.w	r3, r3, #4
 8000b88:	6013      	str	r3, [r2, #0]
			break;
 8000b8a:	e00b      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		case CAN_BaudRate_50:
			CAN_BTR |=0x001C0009;
 8000b8c:	4b6e      	ldr	r3, [pc, #440]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b8e:	681b      	ldr	r3, [r3, #0]
 8000b90:	4a6d      	ldr	r2, [pc, #436]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000b92:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8000b96:	f043 0309 	orr.w	r3, r3, #9
 8000b9a:	6013      	str	r3, [r2, #0]
			break;
 8000b9c:	e002      	b.n	8000ba4 <MCAL_CAN_Init+0xd8>
		default:
			status=CAN_ERROR;
 8000b9e:	2301      	movs	r3, #1
 8000ba0:	73fb      	strb	r3, [r7, #15]
			break;
 8000ba2:	bf00      	nop
	}
	//Configure CAN operating mode
	switch (Can_Config->Mode)
 8000ba4:	687b      	ldr	r3, [r7, #4]
 8000ba6:	681b      	ldr	r3, [r3, #0]
 8000ba8:	2b03      	cmp	r3, #3
 8000baa:	d83f      	bhi.n	8000c2c <MCAL_CAN_Init+0x160>
 8000bac:	a201      	add	r2, pc, #4	; (adr r2, 8000bb4 <MCAL_CAN_Init+0xe8>)
 8000bae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000bb2:	bf00      	nop
 8000bb4:	08000bc5 	.word	0x08000bc5
 8000bb8:	08000bdf 	.word	0x08000bdf
 8000bbc:	08000bf9 	.word	0x08000bf9
 8000bc0:	08000c13 	.word	0x08000c13
	{
		case CAN_MODE_Silent:
			CAN_BTR |=(1<<31);
 8000bc4:	4b60      	ldr	r3, [pc, #384]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bc6:	681b      	ldr	r3, [r3, #0]
 8000bc8:	4a5f      	ldr	r2, [pc, #380]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bca:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bce:	6013      	str	r3, [r2, #0]
			CAN_BTR &=~(1<<30);
 8000bd0:	4b5d      	ldr	r3, [pc, #372]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bd2:	681b      	ldr	r3, [r3, #0]
 8000bd4:	4a5c      	ldr	r2, [pc, #368]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bd6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8000bda:	6013      	str	r3, [r2, #0]
			break;
 8000bdc:	e029      	b.n	8000c32 <MCAL_CAN_Init+0x166>
		case CAN_MODE_Loop_back:
			CAN_BTR |=(1<<30);
 8000bde:	4b5a      	ldr	r3, [pc, #360]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000be0:	681b      	ldr	r3, [r3, #0]
 8000be2:	4a59      	ldr	r2, [pc, #356]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000be4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000be8:	6013      	str	r3, [r2, #0]
			CAN_BTR &=~(1<<31);
 8000bea:	4b57      	ldr	r3, [pc, #348]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bec:	681b      	ldr	r3, [r3, #0]
 8000bee:	4a56      	ldr	r2, [pc, #344]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bf0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8000bf4:	6013      	str	r3, [r2, #0]
			break;
 8000bf6:	e01c      	b.n	8000c32 <MCAL_CAN_Init+0x166>
		case CAN_MODE_Loop_back_Silent:
			CAN_BTR |=(1<<31);
 8000bf8:	4b53      	ldr	r3, [pc, #332]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bfa:	681b      	ldr	r3, [r3, #0]
 8000bfc:	4a52      	ldr	r2, [pc, #328]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000bfe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000c02:	6013      	str	r3, [r2, #0]
			CAN_BTR |=(1<<30);
 8000c04:	4b50      	ldr	r3, [pc, #320]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c06:	681b      	ldr	r3, [r3, #0]
 8000c08:	4a4f      	ldr	r2, [pc, #316]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c0a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000c0e:	6013      	str	r3, [r2, #0]
			break;
 8000c10:	e00f      	b.n	8000c32 <MCAL_CAN_Init+0x166>
		case CAN_MODE_Normal:
			CAN_BTR &=~(1<<31);
 8000c12:	4b4d      	ldr	r3, [pc, #308]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c14:	681b      	ldr	r3, [r3, #0]
 8000c16:	4a4c      	ldr	r2, [pc, #304]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c18:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8000c1c:	6013      	str	r3, [r2, #0]
			CAN_BTR &=~(1<<30);
 8000c1e:	4b4a      	ldr	r3, [pc, #296]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c20:	681b      	ldr	r3, [r3, #0]
 8000c22:	4a49      	ldr	r2, [pc, #292]	; (8000d48 <MCAL_CAN_Init+0x27c>)
 8000c24:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8000c28:	6013      	str	r3, [r2, #0]
			break;
 8000c2a:	e002      	b.n	8000c32 <MCAL_CAN_Init+0x166>
		default:
			status=CAN_ERROR;
 8000c2c:	2301      	movs	r3, #1
 8000c2e:	73fb      	strb	r3, [r7, #15]
			break;
 8000c30:	bf00      	nop
	}
	// Configure recover from Bus-Off  either automatically or on software
	switch (Can_Config->AutoBusOff)
 8000c32:	687b      	ldr	r3, [r7, #4]
 8000c34:	799b      	ldrb	r3, [r3, #6]
 8000c36:	2b00      	cmp	r3, #0
 8000c38:	d002      	beq.n	8000c40 <MCAL_CAN_Init+0x174>
 8000c3a:	2b01      	cmp	r3, #1
 8000c3c:	d007      	beq.n	8000c4e <MCAL_CAN_Init+0x182>
 8000c3e:	e00d      	b.n	8000c5c <MCAL_CAN_Init+0x190>
	{
		case CAN_AutoBusOff_Disable:
			CAN_MCR &=~(1<<6);
 8000c40:	4b40      	ldr	r3, [pc, #256]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	4a3f      	ldr	r2, [pc, #252]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c46:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000c4a:	6013      	str	r3, [r2, #0]
			break;
 8000c4c:	e009      	b.n	8000c62 <MCAL_CAN_Init+0x196>
		case CAN_AutoBusOff_Enable:
			CAN_MCR |=(1<<6);
 8000c4e:	4b3d      	ldr	r3, [pc, #244]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c50:	681b      	ldr	r3, [r3, #0]
 8000c52:	4a3c      	ldr	r2, [pc, #240]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000c58:	6013      	str	r3, [r2, #0]
			break;
 8000c5a:	e002      	b.n	8000c62 <MCAL_CAN_Init+0x196>
		default:
			status=CAN_ERROR;
 8000c5c:	2301      	movs	r3, #1
 8000c5e:	73fb      	strb	r3, [r7, #15]
			break;
 8000c60:	bf00      	nop
	}
	//Enable or disable the non automatic retransmission mode.
	switch (Can_Config->AutoRetransmission)
 8000c62:	687b      	ldr	r3, [r7, #4]
 8000c64:	79db      	ldrb	r3, [r3, #7]
 8000c66:	2b00      	cmp	r3, #0
 8000c68:	d002      	beq.n	8000c70 <MCAL_CAN_Init+0x1a4>
 8000c6a:	2b01      	cmp	r3, #1
 8000c6c:	d007      	beq.n	8000c7e <MCAL_CAN_Init+0x1b2>
 8000c6e:	e00d      	b.n	8000c8c <MCAL_CAN_Init+0x1c0>
	{
		case CAN_AutoRetransmission_Disable:
			CAN_MCR |=(1<<4);
 8000c70:	4b34      	ldr	r3, [pc, #208]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c72:	681b      	ldr	r3, [r3, #0]
 8000c74:	4a33      	ldr	r2, [pc, #204]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c76:	f043 0310 	orr.w	r3, r3, #16
 8000c7a:	6013      	str	r3, [r2, #0]
			break;
 8000c7c:	e009      	b.n	8000c92 <MCAL_CAN_Init+0x1c6>
		case CAN_AutoRetransmission_Enable:
			CAN_MCR &=~(1<<4);
 8000c7e:	4b31      	ldr	r3, [pc, #196]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c80:	681b      	ldr	r3, [r3, #0]
 8000c82:	4a30      	ldr	r2, [pc, #192]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000c84:	f023 0310 	bic.w	r3, r3, #16
 8000c88:	6013      	str	r3, [r2, #0]
			break;
 8000c8a:	e002      	b.n	8000c92 <MCAL_CAN_Init+0x1c6>
		default:
			status=CAN_ERROR;
 8000c8c:	2301      	movs	r3, #1
 8000c8e:	73fb      	strb	r3, [r7, #15]
			break;
 8000c90:	bf00      	nop
	}
	// Enable or disable FIFO lock function
	switch (Can_Config->Fifo_Locked)
 8000c92:	687b      	ldr	r3, [r7, #4]
 8000c94:	7a1b      	ldrb	r3, [r3, #8]
 8000c96:	2b00      	cmp	r3, #0
 8000c98:	d002      	beq.n	8000ca0 <MCAL_CAN_Init+0x1d4>
 8000c9a:	2b01      	cmp	r3, #1
 8000c9c:	d007      	beq.n	8000cae <MCAL_CAN_Init+0x1e2>
 8000c9e:	e00d      	b.n	8000cbc <MCAL_CAN_Init+0x1f0>
	{
		case CAN_Fifo_Locked_Disable:
			CAN_MCR &=~(1<<3);
 8000ca0:	4b28      	ldr	r3, [pc, #160]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ca2:	681b      	ldr	r3, [r3, #0]
 8000ca4:	4a27      	ldr	r2, [pc, #156]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ca6:	f023 0308 	bic.w	r3, r3, #8
 8000caa:	6013      	str	r3, [r2, #0]
			break;
 8000cac:	e009      	b.n	8000cc2 <MCAL_CAN_Init+0x1f6>
		case CAN_Fifo_Locked_Enable:
			CAN_MCR |=(1<<3);
 8000cae:	4b25      	ldr	r3, [pc, #148]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000cb0:	681b      	ldr	r3, [r3, #0]
 8000cb2:	4a24      	ldr	r2, [pc, #144]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000cb4:	f043 0308 	orr.w	r3, r3, #8
 8000cb8:	6013      	str	r3, [r2, #0]
			break;
 8000cba:	e002      	b.n	8000cc2 <MCAL_CAN_Init+0x1f6>
		default:
			status=CAN_ERROR;
 8000cbc:	2301      	movs	r3, #1
 8000cbe:	73fb      	strb	r3, [r7, #15]
			break;
 8000cc0:	bf00      	nop
	}
	// Configure FIFO priority By identifier (Enable) or By transmit request order
	switch (Can_Config->Transmit_Priority)
 8000cc2:	687b      	ldr	r3, [r7, #4]
 8000cc4:	7a5b      	ldrb	r3, [r3, #9]
 8000cc6:	2b00      	cmp	r3, #0
 8000cc8:	d002      	beq.n	8000cd0 <MCAL_CAN_Init+0x204>
 8000cca:	2b01      	cmp	r3, #1
 8000ccc:	d007      	beq.n	8000cde <MCAL_CAN_Init+0x212>
 8000cce:	e00d      	b.n	8000cec <MCAL_CAN_Init+0x220>
	{
		case CAN_Fifo_Transmit_Priority_Disable:
			CAN_MCR |=(1<<2);
 8000cd0:	4b1c      	ldr	r3, [pc, #112]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000cd2:	681b      	ldr	r3, [r3, #0]
 8000cd4:	4a1b      	ldr	r2, [pc, #108]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000cd6:	f043 0304 	orr.w	r3, r3, #4
 8000cda:	6013      	str	r3, [r2, #0]
			break;
 8000cdc:	e009      	b.n	8000cf2 <MCAL_CAN_Init+0x226>
		case CAN_Fifo_Transmit_Priority_Enable:
			CAN_MCR &=~(1<<2);
 8000cde:	4b19      	ldr	r3, [pc, #100]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ce0:	681b      	ldr	r3, [r3, #0]
 8000ce2:	4a18      	ldr	r2, [pc, #96]	; (8000d44 <MCAL_CAN_Init+0x278>)
 8000ce4:	f023 0304 	bic.w	r3, r3, #4
 8000ce8:	6013      	str	r3, [r2, #0]
			break;
 8000cea:	e002      	b.n	8000cf2 <MCAL_CAN_Init+0x226>
		default:
			status=CAN_ERROR;
 8000cec:	2301      	movs	r3, #1
 8000cee:	73fb      	strb	r3, [r7, #15]
			break;
 8000cf0:	bf00      	nop
	}
	// disable or enable Transmit interrupt
	switch (Can_Config->TX_IRQ_EN)
 8000cf2:	687b      	ldr	r3, [r7, #4]
 8000cf4:	7a9b      	ldrb	r3, [r3, #10]
 8000cf6:	2b00      	cmp	r3, #0
 8000cf8:	d002      	beq.n	8000d00 <MCAL_CAN_Init+0x234>
 8000cfa:	2b01      	cmp	r3, #1
 8000cfc:	d00a      	beq.n	8000d14 <MCAL_CAN_Init+0x248>
 8000cfe:	e016      	b.n	8000d2e <MCAL_CAN_Init+0x262>
	{
		case CAN_TX_IRQ_EN_Disable:
			CAN_IER &=~(1<<0);
 8000d00:	4b12      	ldr	r3, [pc, #72]	; (8000d4c <MCAL_CAN_Init+0x280>)
 8000d02:	681b      	ldr	r3, [r3, #0]
 8000d04:	4a11      	ldr	r2, [pc, #68]	; (8000d4c <MCAL_CAN_Init+0x280>)
 8000d06:	f023 0301 	bic.w	r3, r3, #1
 8000d0a:	6013      	str	r3, [r2, #0]
			//assign null pointer to call back function
			Can_Config->P_TX_IRQ=NULL;
 8000d0c:	687b      	ldr	r3, [r7, #4]
 8000d0e:	2200      	movs	r2, #0
 8000d10:	611a      	str	r2, [r3, #16]
			break;
 8000d12:	e00f      	b.n	8000d34 <MCAL_CAN_Init+0x268>
		case CAN_TX_IRQ_EN_Enable:
			CAN_IER |=(1<<0);
 8000d14:	4b0d      	ldr	r3, [pc, #52]	; (8000d4c <MCAL_CAN_Init+0x280>)
 8000d16:	681b      	ldr	r3, [r3, #0]
 8000d18:	4a0c      	ldr	r2, [pc, #48]	; (8000d4c <MCAL_CAN_Init+0x280>)
 8000d1a:	f043 0301 	orr.w	r3, r3, #1
 8000d1e:	6013      	str	r3, [r2, #0]
			NVIC_IRQ19_CAN_TX_Enable();
 8000d20:	4b0b      	ldr	r3, [pc, #44]	; (8000d50 <MCAL_CAN_Init+0x284>)
 8000d22:	681b      	ldr	r3, [r3, #0]
 8000d24:	4a0a      	ldr	r2, [pc, #40]	; (8000d50 <MCAL_CAN_Init+0x284>)
 8000d26:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000d2a:	6013      	str	r3, [r2, #0]
			break;
 8000d2c:	e002      	b.n	8000d34 <MCAL_CAN_Init+0x268>
		default:
			status=CAN_ERROR;
 8000d2e:	2301      	movs	r3, #1
 8000d30:	73fb      	strb	r3, [r7, #15]
			break;
 8000d32:	bf00      	nop
	}
	// disable or enable Receive Fifo 0 interrupt
	switch (Can_Config->RX0_IRQ_EN)
 8000d34:	687b      	ldr	r3, [r7, #4]
 8000d36:	7adb      	ldrb	r3, [r3, #11]
 8000d38:	2b00      	cmp	r3, #0
 8000d3a:	d00b      	beq.n	8000d54 <MCAL_CAN_Init+0x288>
 8000d3c:	2b01      	cmp	r3, #1
 8000d3e:	d01f      	beq.n	8000d80 <MCAL_CAN_Init+0x2b4>
 8000d40:	e037      	b.n	8000db2 <MCAL_CAN_Init+0x2e6>
 8000d42:	bf00      	nop
 8000d44:	40006400 	.word	0x40006400
 8000d48:	4000641c 	.word	0x4000641c
 8000d4c:	40006414 	.word	0x40006414
 8000d50:	e000e100 	.word	0xe000e100
	{
		case CAN_RX0_IRQ_EN_Disable:
			//FIFO message pending interrupt disable
			CAN_IER &=~(1<<1);
 8000d54:	4b71      	ldr	r3, [pc, #452]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d56:	681b      	ldr	r3, [r3, #0]
 8000d58:	4a70      	ldr	r2, [pc, #448]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d5a:	f023 0302 	bic.w	r3, r3, #2
 8000d5e:	6013      	str	r3, [r2, #0]
			//FIFO full interrupt disable
			CAN_IER &=~(1<<2);
 8000d60:	4b6e      	ldr	r3, [pc, #440]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d62:	681b      	ldr	r3, [r3, #0]
 8000d64:	4a6d      	ldr	r2, [pc, #436]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d66:	f023 0304 	bic.w	r3, r3, #4
 8000d6a:	6013      	str	r3, [r2, #0]
			//FIFO overrun interrupt disable
			CAN_IER &=~(1<<3);
 8000d6c:	4b6b      	ldr	r3, [pc, #428]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d6e:	681b      	ldr	r3, [r3, #0]
 8000d70:	4a6a      	ldr	r2, [pc, #424]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d72:	f023 0308 	bic.w	r3, r3, #8
 8000d76:	6013      	str	r3, [r2, #0]
			//assign null pointer to call back function
			Can_Config->P_RX0_IRQ=NULL;
 8000d78:	687b      	ldr	r3, [r7, #4]
 8000d7a:	2200      	movs	r2, #0
 8000d7c:	615a      	str	r2, [r3, #20]
			break;
 8000d7e:	e01b      	b.n	8000db8 <MCAL_CAN_Init+0x2ec>
		case CAN_RX0_IRQ_EN_Enable:
			//FIFO message pending interrupt enable
			CAN_IER |=(1<<1);
 8000d80:	4b66      	ldr	r3, [pc, #408]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d82:	681b      	ldr	r3, [r3, #0]
 8000d84:	4a65      	ldr	r2, [pc, #404]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d86:	f043 0302 	orr.w	r3, r3, #2
 8000d8a:	6013      	str	r3, [r2, #0]
			//FIFO full interrupt enable
			CAN_IER |=(1<<2);
 8000d8c:	4b63      	ldr	r3, [pc, #396]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d8e:	681b      	ldr	r3, [r3, #0]
 8000d90:	4a62      	ldr	r2, [pc, #392]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d92:	f043 0304 	orr.w	r3, r3, #4
 8000d96:	6013      	str	r3, [r2, #0]
			//FIFO overrun interrupt enable
			CAN_IER |=(1<<3);
 8000d98:	4b60      	ldr	r3, [pc, #384]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d9a:	681b      	ldr	r3, [r3, #0]
 8000d9c:	4a5f      	ldr	r2, [pc, #380]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000d9e:	f043 0308 	orr.w	r3, r3, #8
 8000da2:	6013      	str	r3, [r2, #0]
			NVIC_IRQ20_CAN_RX0_Enable();
 8000da4:	4b5e      	ldr	r3, [pc, #376]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000da6:	681b      	ldr	r3, [r3, #0]
 8000da8:	4a5d      	ldr	r2, [pc, #372]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000daa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000dae:	6013      	str	r3, [r2, #0]
			break;
 8000db0:	e002      	b.n	8000db8 <MCAL_CAN_Init+0x2ec>
		default:
			status=CAN_ERROR;
 8000db2:	2301      	movs	r3, #1
 8000db4:	73fb      	strb	r3, [r7, #15]
			break;
 8000db6:	bf00      	nop
	}
	// disable or enable Receive Fifo 1 interrupt
	switch (Can_Config->RX1_IRQ_EN)
 8000db8:	687b      	ldr	r3, [r7, #4]
 8000dba:	7b1b      	ldrb	r3, [r3, #12]
 8000dbc:	2b00      	cmp	r3, #0
 8000dbe:	d002      	beq.n	8000dc6 <MCAL_CAN_Init+0x2fa>
 8000dc0:	2b01      	cmp	r3, #1
 8000dc2:	d016      	beq.n	8000df2 <MCAL_CAN_Init+0x326>
 8000dc4:	e02e      	b.n	8000e24 <MCAL_CAN_Init+0x358>
	{
		case CAN_RX1_IRQ_EN_Disable:
			//FIFO message pending interrupt disable
			CAN_IER &=~(1<<4);
 8000dc6:	4b55      	ldr	r3, [pc, #340]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000dc8:	681b      	ldr	r3, [r3, #0]
 8000dca:	4a54      	ldr	r2, [pc, #336]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000dcc:	f023 0310 	bic.w	r3, r3, #16
 8000dd0:	6013      	str	r3, [r2, #0]
			//FIFO full interrupt disable
			CAN_IER &=~(1<<5);
 8000dd2:	4b52      	ldr	r3, [pc, #328]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000dd4:	681b      	ldr	r3, [r3, #0]
 8000dd6:	4a51      	ldr	r2, [pc, #324]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000dd8:	f023 0320 	bic.w	r3, r3, #32
 8000ddc:	6013      	str	r3, [r2, #0]
			//FIFO overrun interrupt disable
			CAN_IER &=~(1<<6);
 8000dde:	4b4f      	ldr	r3, [pc, #316]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000de0:	681b      	ldr	r3, [r3, #0]
 8000de2:	4a4e      	ldr	r2, [pc, #312]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000de4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000de8:	6013      	str	r3, [r2, #0]
			//assign null pointer to call back function
			Can_Config->P_RX1_IRQ=NULL;
 8000dea:	687b      	ldr	r3, [r7, #4]
 8000dec:	2200      	movs	r2, #0
 8000dee:	619a      	str	r2, [r3, #24]
			break;
 8000df0:	e01b      	b.n	8000e2a <MCAL_CAN_Init+0x35e>
		case CAN_RX1_IRQ_EN_Enable:
			//FIFO message pending interrupt enable
			CAN_IER |=(1<<4);
 8000df2:	4b4a      	ldr	r3, [pc, #296]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000df4:	681b      	ldr	r3, [r3, #0]
 8000df6:	4a49      	ldr	r2, [pc, #292]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000df8:	f043 0310 	orr.w	r3, r3, #16
 8000dfc:	6013      	str	r3, [r2, #0]
			//FIFO full interrupt enable
			CAN_IER |=(1<<5);
 8000dfe:	4b47      	ldr	r3, [pc, #284]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e00:	681b      	ldr	r3, [r3, #0]
 8000e02:	4a46      	ldr	r2, [pc, #280]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e04:	f043 0320 	orr.w	r3, r3, #32
 8000e08:	6013      	str	r3, [r2, #0]
			//FIFO overrun interrupt enable
			CAN_IER |=(1<<6);
 8000e0a:	4b44      	ldr	r3, [pc, #272]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e0c:	681b      	ldr	r3, [r3, #0]
 8000e0e:	4a43      	ldr	r2, [pc, #268]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e10:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000e14:	6013      	str	r3, [r2, #0]
			NVIC_IRQ21_CAN_RX1_Enable();
 8000e16:	4b42      	ldr	r3, [pc, #264]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000e18:	681b      	ldr	r3, [r3, #0]
 8000e1a:	4a41      	ldr	r2, [pc, #260]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000e1c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000e20:	6013      	str	r3, [r2, #0]
			break;
 8000e22:	e002      	b.n	8000e2a <MCAL_CAN_Init+0x35e>
		default:
			status=CAN_ERROR;
 8000e24:	2301      	movs	r3, #1
 8000e26:	73fb      	strb	r3, [r7, #15]
			break;
 8000e28:	bf00      	nop
	}
	// disable or enable Error interrupt
	switch (Can_Config->SCE_IRQ_EN)
 8000e2a:	687b      	ldr	r3, [r7, #4]
 8000e2c:	7b5b      	ldrb	r3, [r3, #13]
 8000e2e:	2b00      	cmp	r3, #0
 8000e30:	d002      	beq.n	8000e38 <MCAL_CAN_Init+0x36c>
 8000e32:	2b01      	cmp	r3, #1
 8000e34:	d022      	beq.n	8000e7c <MCAL_CAN_Init+0x3b0>
 8000e36:	e046      	b.n	8000ec6 <MCAL_CAN_Init+0x3fa>
	{
		case CAN_SCE_IRQ_EN_Disable:
			// general Error interrupt disable
			CAN_IER &=~(1<<15);
 8000e38:	4b38      	ldr	r3, [pc, #224]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	4a37      	ldr	r2, [pc, #220]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e3e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000e42:	6013      	str	r3, [r2, #0]
			 //Error warning interrupt disable
			CAN_IER &=~(1<<8);
 8000e44:	4b35      	ldr	r3, [pc, #212]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e46:	681b      	ldr	r3, [r3, #0]
 8000e48:	4a34      	ldr	r2, [pc, #208]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e4a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000e4e:	6013      	str	r3, [r2, #0]
			 //Error passive interrupt disable
			CAN_IER &=~(1<<9);
 8000e50:	4b32      	ldr	r3, [pc, #200]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e52:	681b      	ldr	r3, [r3, #0]
 8000e54:	4a31      	ldr	r2, [pc, #196]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e56:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000e5a:	6013      	str	r3, [r2, #0]
			 //Bus-off interrupt disable
			CAN_IER &=~(1<<10);
 8000e5c:	4b2f      	ldr	r3, [pc, #188]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e5e:	681b      	ldr	r3, [r3, #0]
 8000e60:	4a2e      	ldr	r2, [pc, #184]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e62:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e66:	6013      	str	r3, [r2, #0]
			//assign null pointer to call back function
			Can_Config->P_SCE_IRQ=NULL;
 8000e68:	687b      	ldr	r3, [r7, #4]
 8000e6a:	2200      	movs	r2, #0
 8000e6c:	61da      	str	r2, [r3, #28]
			//1: ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection.
			// Bit dominant Error or  CRC Error ....
			CAN_IER &=~(1<<11);
 8000e6e:	4b2b      	ldr	r3, [pc, #172]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e70:	681b      	ldr	r3, [r3, #0]
 8000e72:	4a2a      	ldr	r2, [pc, #168]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e74:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000e78:	6013      	str	r3, [r2, #0]
			break;
 8000e7a:	e027      	b.n	8000ecc <MCAL_CAN_Init+0x400>
		case CAN_SCE_IRQ_EN_Enable:
			// general Error interrupt enable
			CAN_IER |=(1<<15);
 8000e7c:	4b27      	ldr	r3, [pc, #156]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e7e:	681b      	ldr	r3, [r3, #0]
 8000e80:	4a26      	ldr	r2, [pc, #152]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e82:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000e86:	6013      	str	r3, [r2, #0]
			 //Error warning interrupt enable
			CAN_IER |=(1<<8);
 8000e88:	4b24      	ldr	r3, [pc, #144]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e8a:	681b      	ldr	r3, [r3, #0]
 8000e8c:	4a23      	ldr	r2, [pc, #140]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e8e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e92:	6013      	str	r3, [r2, #0]
			 //Error passive interrupt enable
			CAN_IER |=(1<<9);
 8000e94:	4b21      	ldr	r3, [pc, #132]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e96:	681b      	ldr	r3, [r3, #0]
 8000e98:	4a20      	ldr	r2, [pc, #128]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000e9a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000e9e:	6013      	str	r3, [r2, #0]
			 //Bus-off interrupt enable
			CAN_IER |=(1<<10);
 8000ea0:	4b1e      	ldr	r3, [pc, #120]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000ea2:	681b      	ldr	r3, [r3, #0]
 8000ea4:	4a1d      	ldr	r2, [pc, #116]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000ea6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000eaa:	6013      	str	r3, [r2, #0]
			//1: ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection.
			// Bit dominant Error or  CRC Error ....
			CAN_IER |=(1<<11);
 8000eac:	4b1b      	ldr	r3, [pc, #108]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000eae:	681b      	ldr	r3, [r3, #0]
 8000eb0:	4a1a      	ldr	r2, [pc, #104]	; (8000f1c <MCAL_CAN_Init+0x450>)
 8000eb2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000eb6:	6013      	str	r3, [r2, #0]
			NVIC_IRQ22_CAN_SCE_Enable();
 8000eb8:	4b19      	ldr	r3, [pc, #100]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000eba:	681b      	ldr	r3, [r3, #0]
 8000ebc:	4a18      	ldr	r2, [pc, #96]	; (8000f20 <MCAL_CAN_Init+0x454>)
 8000ebe:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000ec2:	6013      	str	r3, [r2, #0]
			break;
 8000ec4:	e002      	b.n	8000ecc <MCAL_CAN_Init+0x400>
		default:
			status=CAN_ERROR;
 8000ec6:	2301      	movs	r3, #1
 8000ec8:	73fb      	strb	r3, [r7, #15]
			break;
 8000eca:	bf00      	nop
	 PA12 CAN_TX (Transmit data line) Alternate function push-pull
	 PA11 CAN_RX (Receive data line) Input floating / Input pull-up
	 */
	GPIO_Pinconfig_t PIN;
	//CAN_TX
	PIN.GPIO_MODE=GPIO_MODE_OUTPUT_AF_PP;
 8000ecc:	2306      	movs	r3, #6
 8000ece:	72bb      	strb	r3, [r7, #10]
	PIN.GPIO_OUTPUT_Speed=GPIO_speed_10M;
 8000ed0:	2301      	movs	r3, #1
 8000ed2:	72fb      	strb	r3, [r7, #11]
	PIN.pinNumber=GPIO_PIN_12;
 8000ed4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000ed8:	813b      	strh	r3, [r7, #8]
	MCAL_GPIO_Init(GPIOA, &PIN);
 8000eda:	f107 0308 	add.w	r3, r7, #8
 8000ede:	4619      	mov	r1, r3
 8000ee0:	4810      	ldr	r0, [pc, #64]	; (8000f24 <MCAL_CAN_Init+0x458>)
 8000ee2:	f000 fc6c 	bl	80017be <MCAL_GPIO_Init>
	//CAN_RX
	PIN.GPIO_MODE=GPIO_MODE_INPUT_PU;
 8000ee6:	2302      	movs	r3, #2
 8000ee8:	72bb      	strb	r3, [r7, #10]
	PIN.pinNumber=GPIO_PIN_11;
 8000eea:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000eee:	813b      	strh	r3, [r7, #8]
	MCAL_GPIO_Init(GPIOA, &PIN);
 8000ef0:	f107 0308 	add.w	r3, r7, #8
 8000ef4:	4619      	mov	r1, r3
 8000ef6:	480b      	ldr	r0, [pc, #44]	; (8000f24 <MCAL_CAN_Init+0x458>)
 8000ef8:	f000 fc61 	bl	80017be <MCAL_GPIO_Init>
	g_Can_Config=*Can_Config;
 8000efc:	4a0a      	ldr	r2, [pc, #40]	; (8000f28 <MCAL_CAN_Init+0x45c>)
 8000efe:	687b      	ldr	r3, [r7, #4]
 8000f00:	4614      	mov	r4, r2
 8000f02:	461d      	mov	r5, r3
 8000f04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000f06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000f08:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8000f0c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	return status;
 8000f10:	7bfb      	ldrb	r3, [r7, #15]
}
 8000f12:	4618      	mov	r0, r3
 8000f14:	3710      	adds	r7, #16
 8000f16:	46bd      	mov	sp, r7
 8000f18:	bdb0      	pop	{r4, r5, r7, pc}
 8000f1a:	bf00      	nop
 8000f1c:	40006414 	.word	0x40006414
 8000f20:	e000e100 	.word	0xe000e100
 8000f24:	40010800 	.word	0x40010800
 8000f28:	200003ec 	.word	0x200003ec

08000f2c <MCAL_CAN_Config_Filter>:
* @param [in] 		-Filter_Config: configuration information for the specified Can Filter
* @retval 			-Can_Status_t	status of Can hardware (CAN_OK,CAN_ERROR,...)
* Note				-None
*/
Can_Status_t MCAL_CAN_Config_Filter(CAN_Filter_Config_t* Filter_Config)
{
 8000f2c:	b480      	push	{r7}
 8000f2e:	b085      	sub	sp, #20
 8000f30:	af00      	add	r7, sp, #0
 8000f32:	6078      	str	r0, [r7, #4]
	Can_Status_t status;
	//Check Message_Info pointer
	if(Filter_Config==NULL)
 8000f34:	687b      	ldr	r3, [r7, #4]
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	d103      	bne.n	8000f42 <MCAL_CAN_Config_Filter+0x16>
	{
		status=CAN_ERROR;
 8000f3a:	2301      	movs	r3, #1
 8000f3c:	73fb      	strb	r3, [r7, #15]
		return status;
 8000f3e:	7bfb      	ldrb	r3, [r7, #15]
 8000f40:	e0f9      	b.n	8001136 <MCAL_CAN_Config_Filter+0x20a>
	}
	// Current Filter Bank
	CAN_Filter_Bank_TypeDef* Current_Bank ;
	Current_Bank=NULL;
 8000f42:	2300      	movs	r3, #0
 8000f44:	60bb      	str	r3, [r7, #8]
	switch (Filter_Config->Filter_Bank)
 8000f46:	687b      	ldr	r3, [r7, #4]
 8000f48:	68db      	ldr	r3, [r3, #12]
 8000f4a:	2b0d      	cmp	r3, #13
 8000f4c:	d848      	bhi.n	8000fe0 <MCAL_CAN_Config_Filter+0xb4>
 8000f4e:	a201      	add	r2, pc, #4	; (adr r2, 8000f54 <MCAL_CAN_Config_Filter+0x28>)
 8000f50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000f54:	08000f8d 	.word	0x08000f8d
 8000f58:	08000f93 	.word	0x08000f93
 8000f5c:	08000f99 	.word	0x08000f99
 8000f60:	08000f9f 	.word	0x08000f9f
 8000f64:	08000fa5 	.word	0x08000fa5
 8000f68:	08000fab 	.word	0x08000fab
 8000f6c:	08000fb1 	.word	0x08000fb1
 8000f70:	08000fb7 	.word	0x08000fb7
 8000f74:	08000fbd 	.word	0x08000fbd
 8000f78:	08000fc3 	.word	0x08000fc3
 8000f7c:	08000fc9 	.word	0x08000fc9
 8000f80:	08000fcf 	.word	0x08000fcf
 8000f84:	08000fd5 	.word	0x08000fd5
 8000f88:	08000fdb 	.word	0x08000fdb
	{
		case CAN_Filter_Bank_0:
			Current_Bank=CAN_FBank_0;
 8000f8c:	4b6c      	ldr	r3, [pc, #432]	; (8001140 <MCAL_CAN_Config_Filter+0x214>)
 8000f8e:	60bb      	str	r3, [r7, #8]
			break;
 8000f90:	e029      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_1:
			Current_Bank=CAN_FBank_1;
 8000f92:	4b6c      	ldr	r3, [pc, #432]	; (8001144 <MCAL_CAN_Config_Filter+0x218>)
 8000f94:	60bb      	str	r3, [r7, #8]
			break;
 8000f96:	e026      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_2:
			Current_Bank=CAN_FBank_2;
 8000f98:	4b6b      	ldr	r3, [pc, #428]	; (8001148 <MCAL_CAN_Config_Filter+0x21c>)
 8000f9a:	60bb      	str	r3, [r7, #8]
			break;
 8000f9c:	e023      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_3:
			Current_Bank=CAN_FBank_3;
 8000f9e:	4b6b      	ldr	r3, [pc, #428]	; (800114c <MCAL_CAN_Config_Filter+0x220>)
 8000fa0:	60bb      	str	r3, [r7, #8]
			break;
 8000fa2:	e020      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_4:
			Current_Bank=CAN_FBank_4;
 8000fa4:	4b6a      	ldr	r3, [pc, #424]	; (8001150 <MCAL_CAN_Config_Filter+0x224>)
 8000fa6:	60bb      	str	r3, [r7, #8]
			break;
 8000fa8:	e01d      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_5:
			Current_Bank=CAN_FBank_5;
 8000faa:	4b6a      	ldr	r3, [pc, #424]	; (8001154 <MCAL_CAN_Config_Filter+0x228>)
 8000fac:	60bb      	str	r3, [r7, #8]
			break;
 8000fae:	e01a      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_6:
			Current_Bank=CAN_FBank_6;
 8000fb0:	4b69      	ldr	r3, [pc, #420]	; (8001158 <MCAL_CAN_Config_Filter+0x22c>)
 8000fb2:	60bb      	str	r3, [r7, #8]
			break;
 8000fb4:	e017      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_7:
			Current_Bank=CAN_FBank_7;
 8000fb6:	4b69      	ldr	r3, [pc, #420]	; (800115c <MCAL_CAN_Config_Filter+0x230>)
 8000fb8:	60bb      	str	r3, [r7, #8]
			break;
 8000fba:	e014      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_8:
			Current_Bank=CAN_FBank_8;
 8000fbc:	4b68      	ldr	r3, [pc, #416]	; (8001160 <MCAL_CAN_Config_Filter+0x234>)
 8000fbe:	60bb      	str	r3, [r7, #8]
			break;
 8000fc0:	e011      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_9:
			Current_Bank=CAN_FBank_9;
 8000fc2:	4b68      	ldr	r3, [pc, #416]	; (8001164 <MCAL_CAN_Config_Filter+0x238>)
 8000fc4:	60bb      	str	r3, [r7, #8]
			break;
 8000fc6:	e00e      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_10:
			Current_Bank=CAN_FBank_10;
 8000fc8:	4b67      	ldr	r3, [pc, #412]	; (8001168 <MCAL_CAN_Config_Filter+0x23c>)
 8000fca:	60bb      	str	r3, [r7, #8]
			break;
 8000fcc:	e00b      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_11:
			Current_Bank=CAN_FBank_11;
 8000fce:	4b67      	ldr	r3, [pc, #412]	; (800116c <MCAL_CAN_Config_Filter+0x240>)
 8000fd0:	60bb      	str	r3, [r7, #8]
			break;
 8000fd2:	e008      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_12:
			Current_Bank=CAN_FBank_12;
 8000fd4:	4b66      	ldr	r3, [pc, #408]	; (8001170 <MCAL_CAN_Config_Filter+0x244>)
 8000fd6:	60bb      	str	r3, [r7, #8]
			break;
 8000fd8:	e005      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		case CAN_Filter_Bank_13:
			Current_Bank=CAN_FBank_13;
 8000fda:	4b66      	ldr	r3, [pc, #408]	; (8001174 <MCAL_CAN_Config_Filter+0x248>)
 8000fdc:	60bb      	str	r3, [r7, #8]
			break;
 8000fde:	e002      	b.n	8000fe6 <MCAL_CAN_Config_Filter+0xba>
		default:
			status=CAN_ERROR;
 8000fe0:	2301      	movs	r3, #1
 8000fe2:	73fb      	strb	r3, [r7, #15]
			break;
 8000fe4:	bf00      	nop
	}
	// To configure a filter bank it must be deactivated by clearing the FACT bit in the CAN_FAR register
	// Initialization mode for the filters
	CAN_FMR |=(1<<0);
 8000fe6:	4b64      	ldr	r3, [pc, #400]	; (8001178 <MCAL_CAN_Config_Filter+0x24c>)
 8000fe8:	681b      	ldr	r3, [r3, #0]
 8000fea:	4a63      	ldr	r2, [pc, #396]	; (8001178 <MCAL_CAN_Config_Filter+0x24c>)
 8000fec:	f043 0301 	orr.w	r3, r3, #1
 8000ff0:	6013      	str	r3, [r2, #0]
	//Filter x is not active
	CAN_FA1R &=~(1<<Filter_Config->Filter_Bank);
 8000ff2:	4b62      	ldr	r3, [pc, #392]	; (800117c <MCAL_CAN_Config_Filter+0x250>)
 8000ff4:	681b      	ldr	r3, [r3, #0]
 8000ff6:	687a      	ldr	r2, [r7, #4]
 8000ff8:	68d2      	ldr	r2, [r2, #12]
 8000ffa:	2101      	movs	r1, #1
 8000ffc:	fa01 f202 	lsl.w	r2, r1, r2
 8001000:	43d2      	mvns	r2, r2
 8001002:	4611      	mov	r1, r2
 8001004:	4a5d      	ldr	r2, [pc, #372]	; (800117c <MCAL_CAN_Config_Filter+0x250>)
 8001006:	400b      	ands	r3, r1
 8001008:	6013      	str	r3, [r2, #0]
	// The filter scale is configured by means of the corresponding FSCx bit in the CAN_FS1R register
	switch (Filter_Config->Filter_Scale)
 800100a:	687b      	ldr	r3, [r7, #4]
 800100c:	695b      	ldr	r3, [r3, #20]
 800100e:	2b00      	cmp	r3, #0
 8001010:	d002      	beq.n	8001018 <MCAL_CAN_Config_Filter+0xec>
 8001012:	2b01      	cmp	r3, #1
 8001014:	d020      	beq.n	8001058 <MCAL_CAN_Config_Filter+0x12c>
 8001016:	e033      	b.n	8001080 <MCAL_CAN_Config_Filter+0x154>
	{
		case CAN_Filter_Scale_16:
			CAN_FS1R &=~(1<<Filter_Config->Filter_Bank);
 8001018:	4b59      	ldr	r3, [pc, #356]	; (8001180 <MCAL_CAN_Config_Filter+0x254>)
 800101a:	681b      	ldr	r3, [r3, #0]
 800101c:	687a      	ldr	r2, [r7, #4]
 800101e:	68d2      	ldr	r2, [r2, #12]
 8001020:	2101      	movs	r1, #1
 8001022:	fa01 f202 	lsl.w	r2, r1, r2
 8001026:	43d2      	mvns	r2, r2
 8001028:	4611      	mov	r1, r2
 800102a:	4a55      	ldr	r2, [pc, #340]	; (8001180 <MCAL_CAN_Config_Filter+0x254>)
 800102c:	400b      	ands	r3, r1
 800102e:	6013      	str	r3, [r2, #0]
			// configure filter bank
			Current_Bank->CAN_FiR1=(Filter_Config->Filter_ID &(0xffff))|((Filter_Config->Filter_Mask_ID &(0xffff))<<16);
 8001030:	687b      	ldr	r3, [r7, #4]
 8001032:	681b      	ldr	r3, [r3, #0]
 8001034:	b29a      	uxth	r2, r3
 8001036:	687b      	ldr	r3, [r7, #4]
 8001038:	685b      	ldr	r3, [r3, #4]
 800103a:	041b      	lsls	r3, r3, #16
 800103c:	431a      	orrs	r2, r3
 800103e:	68bb      	ldr	r3, [r7, #8]
 8001040:	601a      	str	r2, [r3, #0]
			Current_Bank->CAN_FiR2=((Filter_Config->Filter_ID &(0xffff0000))>>16)|(Filter_Config->Filter_Mask_ID &(0xffff0000));
 8001042:	687b      	ldr	r3, [r7, #4]
 8001044:	681b      	ldr	r3, [r3, #0]
 8001046:	0c1a      	lsrs	r2, r3, #16
 8001048:	687b      	ldr	r3, [r7, #4]
 800104a:	685b      	ldr	r3, [r3, #4]
 800104c:	0c1b      	lsrs	r3, r3, #16
 800104e:	041b      	lsls	r3, r3, #16
 8001050:	431a      	orrs	r2, r3
 8001052:	68bb      	ldr	r3, [r7, #8]
 8001054:	605a      	str	r2, [r3, #4]
			break;
 8001056:	e016      	b.n	8001086 <MCAL_CAN_Config_Filter+0x15a>
		case CAN_Filter_Scale_32:
			CAN_FS1R |=(1<<Filter_Config->Filter_Bank);
 8001058:	4b49      	ldr	r3, [pc, #292]	; (8001180 <MCAL_CAN_Config_Filter+0x254>)
 800105a:	681b      	ldr	r3, [r3, #0]
 800105c:	687a      	ldr	r2, [r7, #4]
 800105e:	68d2      	ldr	r2, [r2, #12]
 8001060:	2101      	movs	r1, #1
 8001062:	fa01 f202 	lsl.w	r2, r1, r2
 8001066:	4611      	mov	r1, r2
 8001068:	4a45      	ldr	r2, [pc, #276]	; (8001180 <MCAL_CAN_Config_Filter+0x254>)
 800106a:	430b      	orrs	r3, r1
 800106c:	6013      	str	r3, [r2, #0]
			// configure filter bank
			Current_Bank->CAN_FiR1=Filter_Config->Filter_ID;
 800106e:	687b      	ldr	r3, [r7, #4]
 8001070:	681a      	ldr	r2, [r3, #0]
 8001072:	68bb      	ldr	r3, [r7, #8]
 8001074:	601a      	str	r2, [r3, #0]
			Current_Bank->CAN_FiR2=Filter_Config->Filter_Mask_ID;
 8001076:	687b      	ldr	r3, [r7, #4]
 8001078:	685a      	ldr	r2, [r3, #4]
 800107a:	68bb      	ldr	r3, [r7, #8]
 800107c:	605a      	str	r2, [r3, #4]
			break;
 800107e:	e002      	b.n	8001086 <MCAL_CAN_Config_Filter+0x15a>
		default:
			status=CAN_ERROR;
 8001080:	2301      	movs	r3, #1
 8001082:	73fb      	strb	r3, [r7, #15]
			break;
 8001084:	bf00      	nop
	}
	//The identifier list or identifier mask mode is configured by means of the FBMx bits in the CAN_FM1R register.
	switch (Filter_Config->Filter_Mode)
 8001086:	687b      	ldr	r3, [r7, #4]
 8001088:	691b      	ldr	r3, [r3, #16]
 800108a:	2b00      	cmp	r3, #0
 800108c:	d002      	beq.n	8001094 <MCAL_CAN_Config_Filter+0x168>
 800108e:	2b01      	cmp	r3, #1
 8001090:	d00d      	beq.n	80010ae <MCAL_CAN_Config_Filter+0x182>
 8001092:	e018      	b.n	80010c6 <MCAL_CAN_Config_Filter+0x19a>
	{
		case CAN_Filter_Mode_Mask:
			CAN_FM1R &=~(1<<Filter_Config->Filter_Bank);
 8001094:	4b3b      	ldr	r3, [pc, #236]	; (8001184 <MCAL_CAN_Config_Filter+0x258>)
 8001096:	681b      	ldr	r3, [r3, #0]
 8001098:	687a      	ldr	r2, [r7, #4]
 800109a:	68d2      	ldr	r2, [r2, #12]
 800109c:	2101      	movs	r1, #1
 800109e:	fa01 f202 	lsl.w	r2, r1, r2
 80010a2:	43d2      	mvns	r2, r2
 80010a4:	4611      	mov	r1, r2
 80010a6:	4a37      	ldr	r2, [pc, #220]	; (8001184 <MCAL_CAN_Config_Filter+0x258>)
 80010a8:	400b      	ands	r3, r1
 80010aa:	6013      	str	r3, [r2, #0]
			break;
 80010ac:	e00e      	b.n	80010cc <MCAL_CAN_Config_Filter+0x1a0>
		case CAN_Filter_Mode_List:
			CAN_FM1R |=(1<<Filter_Config->Filter_Bank);
 80010ae:	4b35      	ldr	r3, [pc, #212]	; (8001184 <MCAL_CAN_Config_Filter+0x258>)
 80010b0:	681b      	ldr	r3, [r3, #0]
 80010b2:	687a      	ldr	r2, [r7, #4]
 80010b4:	68d2      	ldr	r2, [r2, #12]
 80010b6:	2101      	movs	r1, #1
 80010b8:	fa01 f202 	lsl.w	r2, r1, r2
 80010bc:	4611      	mov	r1, r2
 80010be:	4a31      	ldr	r2, [pc, #196]	; (8001184 <MCAL_CAN_Config_Filter+0x258>)
 80010c0:	430b      	orrs	r3, r1
 80010c2:	6013      	str	r3, [r2, #0]
			break;
 80010c4:	e002      	b.n	80010cc <MCAL_CAN_Config_Filter+0x1a0>
		default:
			status=CAN_ERROR;
 80010c6:	2301      	movs	r3, #1
 80010c8:	73fb      	strb	r3, [r7, #15]
			break;
 80010ca:	bf00      	nop
	}
	//The message passing through this filter will be stored in the specified FIFO
	switch (Filter_Config->Filter_FIFO_Assignment)
 80010cc:	687b      	ldr	r3, [r7, #4]
 80010ce:	689b      	ldr	r3, [r3, #8]
 80010d0:	2b00      	cmp	r3, #0
 80010d2:	d002      	beq.n	80010da <MCAL_CAN_Config_Filter+0x1ae>
 80010d4:	2b01      	cmp	r3, #1
 80010d6:	d00d      	beq.n	80010f4 <MCAL_CAN_Config_Filter+0x1c8>
 80010d8:	e018      	b.n	800110c <MCAL_CAN_Config_Filter+0x1e0>
	{
		case CAN_Filter_FIFO_Assignment_FIFO0:
			CAN_FFA1R &=~(1<<Filter_Config->Filter_Bank);
 80010da:	4b2b      	ldr	r3, [pc, #172]	; (8001188 <MCAL_CAN_Config_Filter+0x25c>)
 80010dc:	681b      	ldr	r3, [r3, #0]
 80010de:	687a      	ldr	r2, [r7, #4]
 80010e0:	68d2      	ldr	r2, [r2, #12]
 80010e2:	2101      	movs	r1, #1
 80010e4:	fa01 f202 	lsl.w	r2, r1, r2
 80010e8:	43d2      	mvns	r2, r2
 80010ea:	4611      	mov	r1, r2
 80010ec:	4a26      	ldr	r2, [pc, #152]	; (8001188 <MCAL_CAN_Config_Filter+0x25c>)
 80010ee:	400b      	ands	r3, r1
 80010f0:	6013      	str	r3, [r2, #0]
			break;
 80010f2:	e00e      	b.n	8001112 <MCAL_CAN_Config_Filter+0x1e6>
		case CAN_Filter_FIFO_Assignment_FIFO1:
			CAN_FFA1R |=(1<<Filter_Config->Filter_Bank);
 80010f4:	4b24      	ldr	r3, [pc, #144]	; (8001188 <MCAL_CAN_Config_Filter+0x25c>)
 80010f6:	681b      	ldr	r3, [r3, #0]
 80010f8:	687a      	ldr	r2, [r7, #4]
 80010fa:	68d2      	ldr	r2, [r2, #12]
 80010fc:	2101      	movs	r1, #1
 80010fe:	fa01 f202 	lsl.w	r2, r1, r2
 8001102:	4611      	mov	r1, r2
 8001104:	4a20      	ldr	r2, [pc, #128]	; (8001188 <MCAL_CAN_Config_Filter+0x25c>)
 8001106:	430b      	orrs	r3, r1
 8001108:	6013      	str	r3, [r2, #0]
			break;
 800110a:	e002      	b.n	8001112 <MCAL_CAN_Config_Filter+0x1e6>
		default:
			status=CAN_ERROR;
 800110c:	2301      	movs	r3, #1
 800110e:	73fb      	strb	r3, [r7, #15]
			break;
 8001110:	bf00      	nop
	}
	// Filter Bank active mode
	CAN_FMR &=~(1<<0);
 8001112:	4b19      	ldr	r3, [pc, #100]	; (8001178 <MCAL_CAN_Config_Filter+0x24c>)
 8001114:	681b      	ldr	r3, [r3, #0]
 8001116:	4a18      	ldr	r2, [pc, #96]	; (8001178 <MCAL_CAN_Config_Filter+0x24c>)
 8001118:	f023 0301 	bic.w	r3, r3, #1
 800111c:	6013      	str	r3, [r2, #0]
	//Filter x is not active
	CAN_FA1R |=(1<<Filter_Config->Filter_Bank);
 800111e:	4b17      	ldr	r3, [pc, #92]	; (800117c <MCAL_CAN_Config_Filter+0x250>)
 8001120:	681b      	ldr	r3, [r3, #0]
 8001122:	687a      	ldr	r2, [r7, #4]
 8001124:	68d2      	ldr	r2, [r2, #12]
 8001126:	2101      	movs	r1, #1
 8001128:	fa01 f202 	lsl.w	r2, r1, r2
 800112c:	4611      	mov	r1, r2
 800112e:	4a13      	ldr	r2, [pc, #76]	; (800117c <MCAL_CAN_Config_Filter+0x250>)
 8001130:	430b      	orrs	r3, r1
 8001132:	6013      	str	r3, [r2, #0]
	return status;
 8001134:	7bfb      	ldrb	r3, [r7, #15]
}
 8001136:	4618      	mov	r0, r3
 8001138:	3714      	adds	r7, #20
 800113a:	46bd      	mov	sp, r7
 800113c:	bc80      	pop	{r7}
 800113e:	4770      	bx	lr
 8001140:	40006640 	.word	0x40006640
 8001144:	40006648 	.word	0x40006648
 8001148:	40006650 	.word	0x40006650
 800114c:	40006658 	.word	0x40006658
 8001150:	40006660 	.word	0x40006660
 8001154:	40006668 	.word	0x40006668
 8001158:	40006670 	.word	0x40006670
 800115c:	40006678 	.word	0x40006678
 8001160:	40006680 	.word	0x40006680
 8001164:	40006688 	.word	0x40006688
 8001168:	40006690 	.word	0x40006690
 800116c:	40006698 	.word	0x40006698
 8001170:	400066a0 	.word	0x400066a0
 8001174:	400066a8 	.word	0x400066a8
 8001178:	40006600 	.word	0x40006600
 800117c:	4000661c 	.word	0x4000661c
 8001180:	4000660c 	.word	0x4000660c
 8001184:	40006604 	.word	0x40006604
 8001188:	40006614 	.word	0x40006614

0800118c <MCAL_CAN_Start>:
* @param [in] 		-None
* @retval 			-Can_Status_t	status of Can hardware (CAN_OK,CAN_ERROR,...)
* Note				-None
*/
Can_Status_t MCAL_CAN_Start(void)
{
 800118c:	b480      	push	{r7}
 800118e:	af00      	add	r7, sp, #0
	// enter Normal mode
	CAN_MCR &=~(1<<0);
 8001190:	4b0b      	ldr	r3, [pc, #44]	; (80011c0 <MCAL_CAN_Start+0x34>)
 8001192:	681b      	ldr	r3, [r3, #0]
 8001194:	4a0a      	ldr	r2, [pc, #40]	; (80011c0 <MCAL_CAN_Start+0x34>)
 8001196:	f023 0301 	bic.w	r3, r3, #1
 800119a:	6013      	str	r3, [r2, #0]
	CAN_MCR &=~(1<<1);
 800119c:	4b08      	ldr	r3, [pc, #32]	; (80011c0 <MCAL_CAN_Start+0x34>)
 800119e:	681b      	ldr	r3, [r3, #0]
 80011a0:	4a07      	ldr	r2, [pc, #28]	; (80011c0 <MCAL_CAN_Start+0x34>)
 80011a2:	f023 0302 	bic.w	r3, r3, #2
 80011a6:	6013      	str	r3, [r2, #0]
	/*
	 This bit is cleared by hardware when the CAN hardware has left the initialization mode (to
	 be synchronized on the CAN bus). To be synchronized the hardware has to monitor a
	 sequence of 11 consecutive recessive bits on the CAN RX signal.
	 */
	while(CAN_MSR & (1<<0));
 80011a8:	bf00      	nop
 80011aa:	4b06      	ldr	r3, [pc, #24]	; (80011c4 <MCAL_CAN_Start+0x38>)
 80011ac:	681b      	ldr	r3, [r3, #0]
 80011ae:	f003 0301 	and.w	r3, r3, #1
 80011b2:	2b00      	cmp	r3, #0
 80011b4:	d1f9      	bne.n	80011aa <MCAL_CAN_Start+0x1e>
}
 80011b6:	bf00      	nop
 80011b8:	4618      	mov	r0, r3
 80011ba:	46bd      	mov	sp, r7
 80011bc:	bc80      	pop	{r7}
 80011be:	4770      	bx	lr
 80011c0:	40006400 	.word	0x40006400
 80011c4:	40006404 	.word	0x40006404

080011c8 <MCAL_CAN_Get_TX_Mailboxes_Empty>:
* 					 Transmi_mailbox_0,Transmi_mailbox_1 or Transmi_mailbox_2
* @retval 			-Can_Status_t	The number of an empty transmit mailbox (Transmi_mailbox_0,Transmi_mailbox_1 or Transmi_mailbox_2)
* Note				-None
*/
uint8_t MCAL_CAN_Get_TX_Mailboxes_Empty(void)
{
 80011c8:	b480      	push	{r7}
 80011ca:	af00      	add	r7, sp, #0
	if(CAN_TSR & 1<<26)
 80011cc:	4b0e      	ldr	r3, [pc, #56]	; (8001208 <MCAL_CAN_Get_TX_Mailboxes_Empty+0x40>)
 80011ce:	681b      	ldr	r3, [r3, #0]
 80011d0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80011d4:	2b00      	cmp	r3, #0
 80011d6:	d001      	beq.n	80011dc <MCAL_CAN_Get_TX_Mailboxes_Empty+0x14>
		return Transmi_mailbox_0;
 80011d8:	2300      	movs	r3, #0
 80011da:	e010      	b.n	80011fe <MCAL_CAN_Get_TX_Mailboxes_Empty+0x36>
	else if (CAN_TSR & 1<<27)
 80011dc:	4b0a      	ldr	r3, [pc, #40]	; (8001208 <MCAL_CAN_Get_TX_Mailboxes_Empty+0x40>)
 80011de:	681b      	ldr	r3, [r3, #0]
 80011e0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80011e4:	2b00      	cmp	r3, #0
 80011e6:	d001      	beq.n	80011ec <MCAL_CAN_Get_TX_Mailboxes_Empty+0x24>
		return Transmi_mailbox_1;
 80011e8:	2301      	movs	r3, #1
 80011ea:	e008      	b.n	80011fe <MCAL_CAN_Get_TX_Mailboxes_Empty+0x36>
	else if (CAN_TSR & 1<<28)
 80011ec:	4b06      	ldr	r3, [pc, #24]	; (8001208 <MCAL_CAN_Get_TX_Mailboxes_Empty+0x40>)
 80011ee:	681b      	ldr	r3, [r3, #0]
 80011f0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80011f4:	2b00      	cmp	r3, #0
 80011f6:	d001      	beq.n	80011fc <MCAL_CAN_Get_TX_Mailboxes_Empty+0x34>
		return Transmi_mailbox_2;
 80011f8:	2302      	movs	r3, #2
 80011fa:	e000      	b.n	80011fe <MCAL_CAN_Get_TX_Mailboxes_Empty+0x36>
	else
		return Transmi_mailbox_Full;
 80011fc:	2303      	movs	r3, #3
}
 80011fe:	4618      	mov	r0, r3
 8001200:	46bd      	mov	sp, r7
 8001202:	bc80      	pop	{r7}
 8001204:	4770      	bx	lr
 8001206:	bf00      	nop
 8001208:	40006408 	.word	0x40006408

0800120c <MCAL_CAN_Add_TX_Message>:
* @param [output] 	-pMailbox: Pointer to a variable that will store the assigned transmit mailbox number.
* @retval 			-Can_Status_t	status of Can hardware (CAN_OK,CAN_ERROR,...)
* Note				-None
*/
Can_Status_t MCAL_CAN_Add_TX_Message(CAN_Message_Info_t* Message_Info, uint8_t Data[], uint8_t *Mailbox)
{
 800120c:	b580      	push	{r7, lr}
 800120e:	b088      	sub	sp, #32
 8001210:	af00      	add	r7, sp, #0
 8001212:	60f8      	str	r0, [r7, #12]
 8001214:	60b9      	str	r1, [r7, #8]
 8001216:	607a      	str	r2, [r7, #4]
	Can_Status_t status;
	status=CAN_OK;
 8001218:	2300      	movs	r3, #0
 800121a:	77fb      	strb	r3, [r7, #31]
	//Check Message_Info pointer
	if(Message_Info==NULL)
 800121c:	68fb      	ldr	r3, [r7, #12]
 800121e:	2b00      	cmp	r3, #0
 8001220:	d103      	bne.n	800122a <MCAL_CAN_Add_TX_Message+0x1e>
	{
		status=CAN_ERROR;
 8001222:	2301      	movs	r3, #1
 8001224:	77fb      	strb	r3, [r7, #31]
		return status;
 8001226:	7ffb      	ldrb	r3, [r7, #31]
 8001228:	e0b0      	b.n	800138c <MCAL_CAN_Add_TX_Message+0x180>
	}
	else
	{
		//CAN_OK;
	}
	uint8_t Mailboxe=0;
 800122a:	2300      	movs	r3, #0
 800122c:	75bb      	strb	r3, [r7, #22]
	CAN_TX_mailbox_TypeDef* Current_Mailboxe=NULL;
 800122e:	2300      	movs	r3, #0
 8001230:	61bb      	str	r3, [r7, #24]
	Mailboxe=MCAL_CAN_Get_TX_Mailboxes_Empty();
 8001232:	f7ff ffc9 	bl	80011c8 <MCAL_CAN_Get_TX_Mailboxes_Empty>
 8001236:	4603      	mov	r3, r0
 8001238:	75bb      	strb	r3, [r7, #22]
	*Mailbox=Mailboxe;
 800123a:	687b      	ldr	r3, [r7, #4]
 800123c:	7dba      	ldrb	r2, [r7, #22]
 800123e:	701a      	strb	r2, [r3, #0]
	switch (Mailboxe)
 8001240:	7dbb      	ldrb	r3, [r7, #22]
 8001242:	2b01      	cmp	r3, #1
 8001244:	d006      	beq.n	8001254 <MCAL_CAN_Add_TX_Message+0x48>
 8001246:	2b02      	cmp	r3, #2
 8001248:	d007      	beq.n	800125a <MCAL_CAN_Add_TX_Message+0x4e>
 800124a:	2b00      	cmp	r3, #0
 800124c:	d108      	bne.n	8001260 <MCAL_CAN_Add_TX_Message+0x54>
	{
		case Transmi_mailbox_0:
			Current_Mailboxe=CAN_TX_mailbox_0;
 800124e:	4b51      	ldr	r3, [pc, #324]	; (8001394 <MCAL_CAN_Add_TX_Message+0x188>)
 8001250:	61bb      	str	r3, [r7, #24]
			break;
 8001252:	e008      	b.n	8001266 <MCAL_CAN_Add_TX_Message+0x5a>
		case Transmi_mailbox_1:
			Current_Mailboxe=CAN_TX_mailbox_1;
 8001254:	4b50      	ldr	r3, [pc, #320]	; (8001398 <MCAL_CAN_Add_TX_Message+0x18c>)
 8001256:	61bb      	str	r3, [r7, #24]
			break;
 8001258:	e005      	b.n	8001266 <MCAL_CAN_Add_TX_Message+0x5a>
		case Transmi_mailbox_2:
			Current_Mailboxe=CAN_TX_mailbox_2;
 800125a:	4b50      	ldr	r3, [pc, #320]	; (800139c <MCAL_CAN_Add_TX_Message+0x190>)
 800125c:	61bb      	str	r3, [r7, #24]
			break;
 800125e:	e002      	b.n	8001266 <MCAL_CAN_Add_TX_Message+0x5a>
		default:
			status=CAN_ERROR;
 8001260:	2301      	movs	r3, #1
 8001262:	77fb      	strb	r3, [r7, #31]
			break;
 8001264:	bf00      	nop
	}
	//reset Current Mailboxe
	Current_Mailboxe->CAN_TDHxR=0X00000000;
 8001266:	69bb      	ldr	r3, [r7, #24]
 8001268:	2200      	movs	r2, #0
 800126a:	60da      	str	r2, [r3, #12]
	Current_Mailboxe->CAN_TDLxR=0X00000000;
 800126c:	69bb      	ldr	r3, [r7, #24]
 800126e:	2200      	movs	r2, #0
 8001270:	609a      	str	r2, [r3, #8]
	Current_Mailboxe->CAN_TDTxR=0X00000000;
 8001272:	69bb      	ldr	r3, [r7, #24]
 8001274:	2200      	movs	r2, #0
 8001276:	605a      	str	r2, [r3, #4]
	Current_Mailboxe->CAN_TIxR=0X00000000;
 8001278:	69bb      	ldr	r3, [r7, #24]
 800127a:	2200      	movs	r2, #0
 800127c:	601a      	str	r2, [r3, #0]
	//set the type of frame
	switch (Message_Info->RTR)
 800127e:	68fb      	ldr	r3, [r7, #12]
 8001280:	7a5b      	ldrb	r3, [r3, #9]
 8001282:	2b00      	cmp	r3, #0
 8001284:	d008      	beq.n	8001298 <MCAL_CAN_Add_TX_Message+0x8c>
 8001286:	2b01      	cmp	r3, #1
 8001288:	d10d      	bne.n	80012a6 <MCAL_CAN_Add_TX_Message+0x9a>
	{
		case CAN_RTR_Remote_Frame:
			Current_Mailboxe->CAN_TIxR |=(1<<1);
 800128a:	69bb      	ldr	r3, [r7, #24]
 800128c:	681b      	ldr	r3, [r3, #0]
 800128e:	f043 0202 	orr.w	r2, r3, #2
 8001292:	69bb      	ldr	r3, [r7, #24]
 8001294:	601a      	str	r2, [r3, #0]
			break;
 8001296:	e009      	b.n	80012ac <MCAL_CAN_Add_TX_Message+0xa0>
		case CAN_RTR_Data_Frame:
			Current_Mailboxe->CAN_TIxR &=~(1<<1);
 8001298:	69bb      	ldr	r3, [r7, #24]
 800129a:	681b      	ldr	r3, [r3, #0]
 800129c:	f023 0202 	bic.w	r2, r3, #2
 80012a0:	69bb      	ldr	r3, [r7, #24]
 80012a2:	601a      	str	r2, [r3, #0]
			break;
 80012a4:	e002      	b.n	80012ac <MCAL_CAN_Add_TX_Message+0xa0>
		default:
			status=CAN_ERROR;
 80012a6:	2301      	movs	r3, #1
 80012a8:	77fb      	strb	r3, [r7, #31]
			break;
 80012aa:	bf00      	nop
	}
	//set the identifier
	switch (Message_Info->IDE)
 80012ac:	68fb      	ldr	r3, [r7, #12]
 80012ae:	7a1b      	ldrb	r3, [r3, #8]
 80012b0:	2b00      	cmp	r3, #0
 80012b2:	d002      	beq.n	80012ba <MCAL_CAN_Add_TX_Message+0xae>
 80012b4:	2b01      	cmp	r3, #1
 80012b6:	d00f      	beq.n	80012d8 <MCAL_CAN_Add_TX_Message+0xcc>
 80012b8:	e01d      	b.n	80012f6 <MCAL_CAN_Add_TX_Message+0xea>
	{
		case CAN_IDE_Standard:
			Current_Mailboxe->CAN_TIxR &=~(1<<2);
 80012ba:	69bb      	ldr	r3, [r7, #24]
 80012bc:	681b      	ldr	r3, [r3, #0]
 80012be:	f023 0204 	bic.w	r2, r3, #4
 80012c2:	69bb      	ldr	r3, [r7, #24]
 80012c4:	601a      	str	r2, [r3, #0]
			Current_Mailboxe->CAN_TIxR |=(uint32_t)(Message_Info->Std_ID<<21);
 80012c6:	69bb      	ldr	r3, [r7, #24]
 80012c8:	681a      	ldr	r2, [r3, #0]
 80012ca:	68fb      	ldr	r3, [r7, #12]
 80012cc:	685b      	ldr	r3, [r3, #4]
 80012ce:	055b      	lsls	r3, r3, #21
 80012d0:	431a      	orrs	r2, r3
 80012d2:	69bb      	ldr	r3, [r7, #24]
 80012d4:	601a      	str	r2, [r3, #0]
			break;
 80012d6:	e011      	b.n	80012fc <MCAL_CAN_Add_TX_Message+0xf0>
		case CAN_IDE_Extended:
			Current_Mailboxe->CAN_TIxR |=(1<<2);
 80012d8:	69bb      	ldr	r3, [r7, #24]
 80012da:	681b      	ldr	r3, [r3, #0]
 80012dc:	f043 0204 	orr.w	r2, r3, #4
 80012e0:	69bb      	ldr	r3, [r7, #24]
 80012e2:	601a      	str	r2, [r3, #0]
			Current_Mailboxe->CAN_TIxR |=(uint32_t)(Message_Info->Ext_ID<<3);
 80012e4:	69bb      	ldr	r3, [r7, #24]
 80012e6:	681a      	ldr	r2, [r3, #0]
 80012e8:	68fb      	ldr	r3, [r7, #12]
 80012ea:	681b      	ldr	r3, [r3, #0]
 80012ec:	00db      	lsls	r3, r3, #3
 80012ee:	431a      	orrs	r2, r3
 80012f0:	69bb      	ldr	r3, [r7, #24]
 80012f2:	601a      	str	r2, [r3, #0]
			break;
 80012f4:	e002      	b.n	80012fc <MCAL_CAN_Add_TX_Message+0xf0>
		default:
			status=CAN_ERROR;
 80012f6:	2301      	movs	r3, #1
 80012f8:	77fb      	strb	r3, [r7, #31]
			break;
 80012fa:	bf00      	nop
	}
	//length of the frame
	if(Message_Info->DLC != CAN_DLC_0)
 80012fc:	68fb      	ldr	r3, [r7, #12]
 80012fe:	68db      	ldr	r3, [r3, #12]
 8001300:	2b00      	cmp	r3, #0
 8001302:	d007      	beq.n	8001314 <MCAL_CAN_Add_TX_Message+0x108>
	{
		Current_Mailboxe->CAN_TDTxR |=(Message_Info->DLC<<0);
 8001304:	69bb      	ldr	r3, [r7, #24]
 8001306:	685a      	ldr	r2, [r3, #4]
 8001308:	68fb      	ldr	r3, [r7, #12]
 800130a:	68db      	ldr	r3, [r3, #12]
 800130c:	431a      	orrs	r2, r3
 800130e:	69bb      	ldr	r3, [r7, #24]
 8001310:	605a      	str	r2, [r3, #4]
 8001312:	e007      	b.n	8001324 <MCAL_CAN_Add_TX_Message+0x118>
	}
	else
	{
		Current_Mailboxe->CAN_TDTxR &=~(Message_Info->DLC<<0);
 8001314:	69bb      	ldr	r3, [r7, #24]
 8001316:	685a      	ldr	r2, [r3, #4]
 8001318:	68fb      	ldr	r3, [r7, #12]
 800131a:	68db      	ldr	r3, [r3, #12]
 800131c:	43db      	mvns	r3, r3
 800131e:	401a      	ands	r2, r3
 8001320:	69bb      	ldr	r3, [r7, #24]
 8001322:	605a      	str	r2, [r3, #4]
	}
	//Data
	for(uint8_t i=0 ; i<(uint8_t)Message_Info->DLC ; i++)
 8001324:	2300      	movs	r3, #0
 8001326:	75fb      	strb	r3, [r7, #23]
 8001328:	e023      	b.n	8001372 <MCAL_CAN_Add_TX_Message+0x166>
	{
		if(i<4)
 800132a:	7dfb      	ldrb	r3, [r7, #23]
 800132c:	2b03      	cmp	r3, #3
 800132e:	d80e      	bhi.n	800134e <MCAL_CAN_Add_TX_Message+0x142>
		{
			Current_Mailboxe->CAN_TDLxR |=Data[i]<<(8*i);
 8001330:	69bb      	ldr	r3, [r7, #24]
 8001332:	689b      	ldr	r3, [r3, #8]
 8001334:	7dfa      	ldrb	r2, [r7, #23]
 8001336:	68b9      	ldr	r1, [r7, #8]
 8001338:	440a      	add	r2, r1
 800133a:	7812      	ldrb	r2, [r2, #0]
 800133c:	4611      	mov	r1, r2
 800133e:	7dfa      	ldrb	r2, [r7, #23]
 8001340:	00d2      	lsls	r2, r2, #3
 8001342:	fa01 f202 	lsl.w	r2, r1, r2
 8001346:	431a      	orrs	r2, r3
 8001348:	69bb      	ldr	r3, [r7, #24]
 800134a:	609a      	str	r2, [r3, #8]
 800134c:	e00e      	b.n	800136c <MCAL_CAN_Add_TX_Message+0x160>
		}
		else
		{
			Current_Mailboxe->CAN_TDHxR |=Data[i]<<(8*(i-4));
 800134e:	69bb      	ldr	r3, [r7, #24]
 8001350:	68db      	ldr	r3, [r3, #12]
 8001352:	7dfa      	ldrb	r2, [r7, #23]
 8001354:	68b9      	ldr	r1, [r7, #8]
 8001356:	440a      	add	r2, r1
 8001358:	7812      	ldrb	r2, [r2, #0]
 800135a:	4611      	mov	r1, r2
 800135c:	7dfa      	ldrb	r2, [r7, #23]
 800135e:	3a04      	subs	r2, #4
 8001360:	00d2      	lsls	r2, r2, #3
 8001362:	fa01 f202 	lsl.w	r2, r1, r2
 8001366:	431a      	orrs	r2, r3
 8001368:	69bb      	ldr	r3, [r7, #24]
 800136a:	60da      	str	r2, [r3, #12]
	for(uint8_t i=0 ; i<(uint8_t)Message_Info->DLC ; i++)
 800136c:	7dfb      	ldrb	r3, [r7, #23]
 800136e:	3301      	adds	r3, #1
 8001370:	75fb      	strb	r3, [r7, #23]
 8001372:	68fb      	ldr	r3, [r7, #12]
 8001374:	68db      	ldr	r3, [r3, #12]
 8001376:	b2db      	uxtb	r3, r3
 8001378:	7dfa      	ldrb	r2, [r7, #23]
 800137a:	429a      	cmp	r2, r3
 800137c:	d3d5      	bcc.n	800132a <MCAL_CAN_Add_TX_Message+0x11e>
		}
	}
	// Transmit mailbox request
	Current_Mailboxe->CAN_TIxR |=(1<<0);
 800137e:	69bb      	ldr	r3, [r7, #24]
 8001380:	681b      	ldr	r3, [r3, #0]
 8001382:	f043 0201 	orr.w	r2, r3, #1
 8001386:	69bb      	ldr	r3, [r7, #24]
 8001388:	601a      	str	r2, [r3, #0]
	// Wait for the previous transmission was successful
	//while(!(CAN_TSR & (1<<1)));
	return status;
 800138a:	7ffb      	ldrb	r3, [r7, #31]
}
 800138c:	4618      	mov	r0, r3
 800138e:	3720      	adds	r7, #32
 8001390:	46bd      	mov	sp, r7
 8001392:	bd80      	pop	{r7, pc}
 8001394:	40006580 	.word	0x40006580
 8001398:	40006590 	.word	0x40006590
 800139c:	400065a0 	.word	0x400065a0

080013a0 <MCAL_CAN_Receive_Message>:
* @param [out]    	-RX_Buffer: Pointer to an array where the received data will be stored.
* @retval         	-Can_Status_t: Status of the message reception (CAN_OK, CAN_ERROR, CAN_NOT_RX_MESSAGE, etc.).
* Note				-None
*/
Can_Status_t MCAL_CAN_Receive_Message(CAN_Message_Info_t* Message_Info, uint8_t* RX_Buffer)
{
 80013a0:	b480      	push	{r7}
 80013a2:	b085      	sub	sp, #20
 80013a4:	af00      	add	r7, sp, #0
 80013a6:	6078      	str	r0, [r7, #4]
 80013a8:	6039      	str	r1, [r7, #0]
	Can_Status_t status;
	status=CAN_OK;
 80013aa:	2300      	movs	r3, #0
 80013ac:	73fb      	strb	r3, [r7, #15]
	// Check fifo empty (fifo 0 and fifo 1)
	//fifo 0
	if((CAN_RF0R & (3<<0)) != 0)
 80013ae:	4b2f      	ldr	r3, [pc, #188]	; (800146c <MCAL_CAN_Receive_Message+0xcc>)
 80013b0:	681b      	ldr	r3, [r3, #0]
 80013b2:	f003 0303 	and.w	r3, r3, #3
 80013b6:	2b00      	cmp	r3, #0
 80013b8:	d024      	beq.n	8001404 <MCAL_CAN_Receive_Message+0x64>
	{
		//Identifier extension
		if((CAN_RX_FIFO_0->CAN_RIxR & (1<<2))==1)
 80013ba:	4b2d      	ldr	r3, [pc, #180]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013bc:	681b      	ldr	r3, [r3, #0]
			Message_Info->Ext_ID=(CAN_RX_FIFO_0->CAN_RIxR>>3);
		}
		else
		{
			//0: Standard identifier
			Message_Info->IDE=CAN_IDE_Standard;
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	2200      	movs	r2, #0
 80013c2:	721a      	strb	r2, [r3, #8]
			//get id
			Message_Info->Std_ID=(CAN_RX_FIFO_0->CAN_RIxR>>21);
 80013c4:	4b2a      	ldr	r3, [pc, #168]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013c6:	681b      	ldr	r3, [r3, #0]
 80013c8:	0d5a      	lsrs	r2, r3, #21
 80013ca:	687b      	ldr	r3, [r7, #4]
 80013cc:	605a      	str	r2, [r3, #4]
		}
		//Type of data frame
		if((CAN_RX_FIFO_0->CAN_RIxR & (1<<1))==1)
 80013ce:	4b28      	ldr	r3, [pc, #160]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013d0:	681b      	ldr	r3, [r3, #0]
			Message_Info->RTR=CAN_RTR_Remote_Frame;
		}
		else
		{
			//0: Data frame
			Message_Info->RTR=CAN_RTR_Data_Frame;
 80013d2:	687b      	ldr	r3, [r7, #4]
 80013d4:	2200      	movs	r2, #0
 80013d6:	725a      	strb	r2, [r3, #9]
		}
		//This field defines the number of data bytes a data frame contains (0 to 8).
		Message_Info->DLC=(CAN_RX_FIFO_0->CAN_RDTxR & 0x0000000F);
 80013d8:	4b25      	ldr	r3, [pc, #148]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013da:	685b      	ldr	r3, [r3, #4]
 80013dc:	f003 020f 	and.w	r2, r3, #15
 80013e0:	687b      	ldr	r3, [r7, #4]
 80013e2:	60da      	str	r2, [r3, #12]
		//CAN receive FIFO mailbox data
		*((volatile uint32_t*)RX_Buffer)=CAN_RX_FIFO_0->CAN_RDLxR;
 80013e4:	4b22      	ldr	r3, [pc, #136]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013e6:	689a      	ldr	r2, [r3, #8]
 80013e8:	683b      	ldr	r3, [r7, #0]
 80013ea:	601a      	str	r2, [r3, #0]
		*(((volatile uint32_t*)RX_Buffer)+1)=CAN_RX_FIFO_0->CAN_RDHxR;
 80013ec:	4a20      	ldr	r2, [pc, #128]	; (8001470 <MCAL_CAN_Receive_Message+0xd0>)
 80013ee:	683b      	ldr	r3, [r7, #0]
 80013f0:	3304      	adds	r3, #4
 80013f2:	68d2      	ldr	r2, [r2, #12]
 80013f4:	601a      	str	r2, [r3, #0]

			}
		}
		*/
		//Set by software to release the output mailbox of the FIFO
		CAN_RF0R |=(1<<5);
 80013f6:	4b1d      	ldr	r3, [pc, #116]	; (800146c <MCAL_CAN_Receive_Message+0xcc>)
 80013f8:	681b      	ldr	r3, [r3, #0]
 80013fa:	4a1c      	ldr	r2, [pc, #112]	; (800146c <MCAL_CAN_Receive_Message+0xcc>)
 80013fc:	f043 0320 	orr.w	r3, r3, #32
 8001400:	6013      	str	r3, [r2, #0]
 8001402:	e02c      	b.n	800145e <MCAL_CAN_Receive_Message+0xbe>
	}
	//fifo 1
	else if ((CAN_RF1R & (3<<0)) != 0)
 8001404:	4b1b      	ldr	r3, [pc, #108]	; (8001474 <MCAL_CAN_Receive_Message+0xd4>)
 8001406:	681b      	ldr	r3, [r3, #0]
 8001408:	f003 0303 	and.w	r3, r3, #3
 800140c:	2b00      	cmp	r3, #0
 800140e:	d024      	beq.n	800145a <MCAL_CAN_Receive_Message+0xba>
	{
		//Identifier extension
		if((CAN_RX_FIFO_1->CAN_RIxR & (1<<2))==1)
 8001410:	4b19      	ldr	r3, [pc, #100]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 8001412:	681b      	ldr	r3, [r3, #0]
			Message_Info->Ext_ID=(CAN_RX_FIFO_1->CAN_RIxR>>3);
		}
		else
		{
			//0: Standard identifier
			Message_Info->IDE=CAN_IDE_Standard;
 8001414:	687b      	ldr	r3, [r7, #4]
 8001416:	2200      	movs	r2, #0
 8001418:	721a      	strb	r2, [r3, #8]
			//get id
			Message_Info->Std_ID=(CAN_RX_FIFO_1->CAN_RIxR>>21);
 800141a:	4b17      	ldr	r3, [pc, #92]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 800141c:	681b      	ldr	r3, [r3, #0]
 800141e:	0d5a      	lsrs	r2, r3, #21
 8001420:	687b      	ldr	r3, [r7, #4]
 8001422:	605a      	str	r2, [r3, #4]
		}
		//Type of data frame
		if((CAN_RX_FIFO_1->CAN_RIxR & (1<<1))==1)
 8001424:	4b14      	ldr	r3, [pc, #80]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 8001426:	681b      	ldr	r3, [r3, #0]
			Message_Info->RTR=CAN_RTR_Remote_Frame;
		}
		else
		{
			//0: Data frame
			Message_Info->RTR=CAN_RTR_Data_Frame;
 8001428:	687b      	ldr	r3, [r7, #4]
 800142a:	2200      	movs	r2, #0
 800142c:	725a      	strb	r2, [r3, #9]
		}
		//This field defines the number of data bytes a data frame contains (0 to 8).
		Message_Info->DLC=(CAN_RX_FIFO_1->CAN_RDTxR & 0x0000000F);
 800142e:	4b12      	ldr	r3, [pc, #72]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 8001430:	685b      	ldr	r3, [r3, #4]
 8001432:	f003 020f 	and.w	r2, r3, #15
 8001436:	687b      	ldr	r3, [r7, #4]
 8001438:	60da      	str	r2, [r3, #12]
		//CAN receive FIFO mailbox data
		*((volatile uint32_t*)RX_Buffer)=CAN_RX_FIFO_1->CAN_RDLxR;
 800143a:	4b0f      	ldr	r3, [pc, #60]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 800143c:	689a      	ldr	r2, [r3, #8]
 800143e:	683b      	ldr	r3, [r7, #0]
 8001440:	601a      	str	r2, [r3, #0]
		*(((volatile uint32_t*)RX_Buffer)+1)=CAN_RX_FIFO_1->CAN_RDHxR;
 8001442:	4a0d      	ldr	r2, [pc, #52]	; (8001478 <MCAL_CAN_Receive_Message+0xd8>)
 8001444:	683b      	ldr	r3, [r7, #0]
 8001446:	3304      	adds	r3, #4
 8001448:	68d2      	ldr	r2, [r2, #12]
 800144a:	601a      	str	r2, [r3, #0]
		//Set by software to release the output mailbox of the FIFO
		CAN_RF1R |=(1<<5);
 800144c:	4b09      	ldr	r3, [pc, #36]	; (8001474 <MCAL_CAN_Receive_Message+0xd4>)
 800144e:	681b      	ldr	r3, [r3, #0]
 8001450:	4a08      	ldr	r2, [pc, #32]	; (8001474 <MCAL_CAN_Receive_Message+0xd4>)
 8001452:	f043 0320 	orr.w	r3, r3, #32
 8001456:	6013      	str	r3, [r2, #0]
 8001458:	e001      	b.n	800145e <MCAL_CAN_Receive_Message+0xbe>
	}
	else
	{
		// not received any data
		status=CAN_NOT_RX_MESSAGE;
 800145a:	2302      	movs	r3, #2
 800145c:	73fb      	strb	r3, [r7, #15]
	}
	return status;
 800145e:	7bfb      	ldrb	r3, [r7, #15]
}
 8001460:	4618      	mov	r0, r3
 8001462:	3714      	adds	r7, #20
 8001464:	46bd      	mov	sp, r7
 8001466:	bc80      	pop	{r7}
 8001468:	4770      	bx	lr
 800146a:	bf00      	nop
 800146c:	4000640c 	.word	0x4000640c
 8001470:	400065b0 	.word	0x400065b0
 8001474:	40006410 	.word	0x40006410
 8001478:	400065c0 	.word	0x400065c0

0800147c <MCAL_CAN_Request_Sleep>:
* @param [in] 		-None
* @retval 			-None
* Note				-None
*/
void MCAL_CAN_Request_Sleep(void)
{
 800147c:	b480      	push	{r7}
 800147e:	af00      	add	r7, sp, #0
	/*
	 This bit is set by software to request the CAN hardware to enter the Sleep mode. Sleep
	 mode will be entered as soon as the current CAN activity (transmission or reception of a
	 CAN frame) has been completed.
	 */
	CAN_MCR |=(1<<1);
 8001480:	4b04      	ldr	r3, [pc, #16]	; (8001494 <MCAL_CAN_Request_Sleep+0x18>)
 8001482:	681b      	ldr	r3, [r3, #0]
 8001484:	4a03      	ldr	r2, [pc, #12]	; (8001494 <MCAL_CAN_Request_Sleep+0x18>)
 8001486:	f043 0302 	orr.w	r3, r3, #2
 800148a:	6013      	str	r3, [r2, #0]
	 This bit is cleared by software to exit Sleep mode.
	This bit is cleared by hardware when the AWUM bit is set and a SOF bit is detected on the
	CAN RX signal.
	This bit is set after reset - CAN starts in Sleep mode
	 */
}
 800148c:	bf00      	nop
 800148e:	46bd      	mov	sp, r7
 8001490:	bc80      	pop	{r7}
 8001492:	4770      	bx	lr
 8001494:	40006400 	.word	0x40006400

08001498 <MCAL_CAN_Get_Mode>:
* @param [in] 		-None
* @retval         	-Can_Mode_t: The current operating mode of the CAN controller (CAN_NORMAL_MODE, CAN_INITIALIZATION_MODE, CAN_SLEEP_MODE).
* Note				-None
*/
Can_Mode_t MCAL_CAN_Get_Mode(void)
{
 8001498:	b480      	push	{r7}
 800149a:	b083      	sub	sp, #12
 800149c:	af00      	add	r7, sp, #0
	Can_Mode_t Mode;
	switch (CAN_MCR & 3)
 800149e:	4b0e      	ldr	r3, [pc, #56]	; (80014d8 <MCAL_CAN_Get_Mode+0x40>)
 80014a0:	681b      	ldr	r3, [r3, #0]
 80014a2:	f003 0303 	and.w	r3, r3, #3
 80014a6:	2b01      	cmp	r3, #1
 80014a8:	d009      	beq.n	80014be <MCAL_CAN_Get_Mode+0x26>
 80014aa:	2b01      	cmp	r3, #1
 80014ac:	d303      	bcc.n	80014b6 <MCAL_CAN_Get_Mode+0x1e>
 80014ae:	2b02      	cmp	r3, #2
 80014b0:	d009      	beq.n	80014c6 <MCAL_CAN_Get_Mode+0x2e>
		case CAN_Sleep_Mode:
			Mode=CAN_SLEEP_MODE;
			return Mode;
			break;
		default:
			break;
 80014b2:	bf00      	nop
	}
}
 80014b4:	e00a      	b.n	80014cc <MCAL_CAN_Get_Mode+0x34>
			Mode=CAN_NORMAL_MODE;
 80014b6:	2300      	movs	r3, #0
 80014b8:	71fb      	strb	r3, [r7, #7]
			return Mode;
 80014ba:	79fb      	ldrb	r3, [r7, #7]
 80014bc:	e006      	b.n	80014cc <MCAL_CAN_Get_Mode+0x34>
			Mode=CAN_INITIALIZATION_MODE;
 80014be:	2301      	movs	r3, #1
 80014c0:	71fb      	strb	r3, [r7, #7]
			return Mode;
 80014c2:	79fb      	ldrb	r3, [r7, #7]
 80014c4:	e002      	b.n	80014cc <MCAL_CAN_Get_Mode+0x34>
			Mode=CAN_SLEEP_MODE;
 80014c6:	2302      	movs	r3, #2
 80014c8:	71fb      	strb	r3, [r7, #7]
			return Mode;
 80014ca:	79fb      	ldrb	r3, [r7, #7]
}
 80014cc:	4618      	mov	r0, r3
 80014ce:	370c      	adds	r7, #12
 80014d0:	46bd      	mov	sp, r7
 80014d2:	bc80      	pop	{r7}
 80014d4:	4770      	bx	lr
 80014d6:	bf00      	nop
 80014d8:	40006400 	.word	0x40006400

080014dc <USB_HP_CAN_TX_IRQHandler>:
/*************************************************************************
 *************************************ISR*********************************
 ************************************************************************/
void USB_HP_CAN_TX_IRQHandler(void)
{
 80014dc:	b580      	push	{r7, lr}
 80014de:	af00      	add	r7, sp, #0
	//Check which mailbox transmit is complete
	// RQCPx: Request completed mailbox
	//Set by hardware when the last request (transmit or abort) has been performed.
	if((CAN_TSR & (1<<0))==1)
 80014e0:	4b0e      	ldr	r3, [pc, #56]	; (800151c <USB_HP_CAN_TX_IRQHandler+0x40>)
 80014e2:	681b      	ldr	r3, [r3, #0]
 80014e4:	f003 0301 	and.w	r3, r3, #1
 80014e8:	2b01      	cmp	r3, #1
 80014ea:	d110      	bne.n	800150e <USB_HP_CAN_TX_IRQHandler+0x32>
	{
		 //Request completed mailbox0
		CAN_TSR |=1<<0;
 80014ec:	4b0b      	ldr	r3, [pc, #44]	; (800151c <USB_HP_CAN_TX_IRQHandler+0x40>)
 80014ee:	681b      	ldr	r3, [r3, #0]
 80014f0:	4a0a      	ldr	r2, [pc, #40]	; (800151c <USB_HP_CAN_TX_IRQHandler+0x40>)
 80014f2:	f043 0301 	orr.w	r3, r3, #1
 80014f6:	6013      	str	r3, [r2, #0]
		if(g_Can_Config.P_TX_IRQ==NULL)
 80014f8:	4b09      	ldr	r3, [pc, #36]	; (8001520 <USB_HP_CAN_TX_IRQHandler+0x44>)
 80014fa:	691b      	ldr	r3, [r3, #16]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d102      	bne.n	8001506 <USB_HP_CAN_TX_IRQHandler+0x2a>
		{
			MCAL_CAN_Mailbox_0_Empty_Callback();
 8001500:	f000 f8ee 	bl	80016e0 <MCAL_CAN_Mailbox_0_Empty_Callback>
	}
	else
	{
		// no call back
	}
}
 8001504:	e007      	b.n	8001516 <USB_HP_CAN_TX_IRQHandler+0x3a>
			g_Can_Config.P_TX_IRQ();
 8001506:	4b06      	ldr	r3, [pc, #24]	; (8001520 <USB_HP_CAN_TX_IRQHandler+0x44>)
 8001508:	691b      	ldr	r3, [r3, #16]
 800150a:	4798      	blx	r3
}
 800150c:	e003      	b.n	8001516 <USB_HP_CAN_TX_IRQHandler+0x3a>
	else if((CAN_TSR & (1<<8))==1)
 800150e:	4b03      	ldr	r3, [pc, #12]	; (800151c <USB_HP_CAN_TX_IRQHandler+0x40>)
 8001510:	681b      	ldr	r3, [r3, #0]
	else if((CAN_TSR & (1<<16))==1)
 8001512:	4b02      	ldr	r3, [pc, #8]	; (800151c <USB_HP_CAN_TX_IRQHandler+0x40>)
 8001514:	681b      	ldr	r3, [r3, #0]
}
 8001516:	bf00      	nop
 8001518:	bd80      	pop	{r7, pc}
 800151a:	bf00      	nop
 800151c:	40006408 	.word	0x40006408
 8001520:	200003ec 	.word	0x200003ec

08001524 <USB_LP_CAN_RX0_IRQHandler>:
void USB_LP_CAN_RX0_IRQHandler(void)
{
 8001524:	b580      	push	{r7, lr}
 8001526:	af00      	add	r7, sp, #0
	//These bits indicate how many messages are pending in the receive FIFO
	if ((CAN_RF0R & (3<<0))!=0)
 8001528:	4b0b      	ldr	r3, [pc, #44]	; (8001558 <USB_LP_CAN_RX0_IRQHandler+0x34>)
 800152a:	681b      	ldr	r3, [r3, #0]
 800152c:	f003 0303 	and.w	r3, r3, #3
 8001530:	2b00      	cmp	r3, #0
 8001532:	d00a      	beq.n	800154a <USB_LP_CAN_RX0_IRQHandler+0x26>
	{
		//FIFO 0 message pending
		if(g_Can_Config.P_RX0_IRQ==NULL)
 8001534:	4b09      	ldr	r3, [pc, #36]	; (800155c <USB_LP_CAN_RX0_IRQHandler+0x38>)
 8001536:	695b      	ldr	r3, [r3, #20]
 8001538:	2b00      	cmp	r3, #0
 800153a:	d102      	bne.n	8001542 <USB_LP_CAN_RX0_IRQHandler+0x1e>
		{
			MCAL_CAN_FIFO_0_Receive_Callback();
 800153c:	f7ff f9bc 	bl	80008b8 <MCAL_CAN_FIFO_0_Receive_Callback>
	}
	else
	{

	}
}
 8001540:	e007      	b.n	8001552 <USB_LP_CAN_RX0_IRQHandler+0x2e>
			g_Can_Config.P_RX0_IRQ();
 8001542:	4b06      	ldr	r3, [pc, #24]	; (800155c <USB_LP_CAN_RX0_IRQHandler+0x38>)
 8001544:	695b      	ldr	r3, [r3, #20]
 8001546:	4798      	blx	r3
}
 8001548:	e003      	b.n	8001552 <USB_LP_CAN_RX0_IRQHandler+0x2e>
	else if((CAN_RF0R & (1<<3))==1)
 800154a:	4b03      	ldr	r3, [pc, #12]	; (8001558 <USB_LP_CAN_RX0_IRQHandler+0x34>)
 800154c:	681b      	ldr	r3, [r3, #0]
	else if((CAN_RF0R & (1<<4))==1)
 800154e:	4b02      	ldr	r3, [pc, #8]	; (8001558 <USB_LP_CAN_RX0_IRQHandler+0x34>)
 8001550:	681b      	ldr	r3, [r3, #0]
}
 8001552:	bf00      	nop
 8001554:	bd80      	pop	{r7, pc}
 8001556:	bf00      	nop
 8001558:	4000640c 	.word	0x4000640c
 800155c:	200003ec 	.word	0x200003ec

08001560 <CAN_RX1_IRQHandler>:
void CAN_RX1_IRQHandler(void)
{
 8001560:	b580      	push	{r7, lr}
 8001562:	af00      	add	r7, sp, #0
	//These bits indicate how many messages are pending in the receive FIFO
	if ((CAN_RF1R & (3<<0))!=0)
 8001564:	4b0b      	ldr	r3, [pc, #44]	; (8001594 <CAN_RX1_IRQHandler+0x34>)
 8001566:	681b      	ldr	r3, [r3, #0]
 8001568:	f003 0303 	and.w	r3, r3, #3
 800156c:	2b00      	cmp	r3, #0
 800156e:	d00a      	beq.n	8001586 <CAN_RX1_IRQHandler+0x26>
	{
		//FIFO 1 message pending
		if(g_Can_Config.P_RX1_IRQ==NULL)
 8001570:	4b09      	ldr	r3, [pc, #36]	; (8001598 <CAN_RX1_IRQHandler+0x38>)
 8001572:	699b      	ldr	r3, [r3, #24]
 8001574:	2b00      	cmp	r3, #0
 8001576:	d102      	bne.n	800157e <CAN_RX1_IRQHandler+0x1e>
		{
			MCAL_CAN_FIFO_1_Receive_Callback();
 8001578:	f000 f8b8 	bl	80016ec <MCAL_CAN_FIFO_1_Receive_Callback>
	}
	else
	{

	}
}
 800157c:	e007      	b.n	800158e <CAN_RX1_IRQHandler+0x2e>
			g_Can_Config.P_RX1_IRQ();
 800157e:	4b06      	ldr	r3, [pc, #24]	; (8001598 <CAN_RX1_IRQHandler+0x38>)
 8001580:	699b      	ldr	r3, [r3, #24]
 8001582:	4798      	blx	r3
}
 8001584:	e003      	b.n	800158e <CAN_RX1_IRQHandler+0x2e>
	else if((CAN_RF1R & (1<<3))==1)
 8001586:	4b03      	ldr	r3, [pc, #12]	; (8001594 <CAN_RX1_IRQHandler+0x34>)
 8001588:	681b      	ldr	r3, [r3, #0]
	else if((CAN_RF1R & (1<<4))==1)
 800158a:	4b02      	ldr	r3, [pc, #8]	; (8001594 <CAN_RX1_IRQHandler+0x34>)
 800158c:	681b      	ldr	r3, [r3, #0]
}
 800158e:	bf00      	nop
 8001590:	bd80      	pop	{r7, pc}
 8001592:	bf00      	nop
 8001594:	40006410 	.word	0x40006410
 8001598:	200003ec 	.word	0x200003ec

0800159c <CAN_SCE_IRQHandler>:
void CAN_SCE_IRQHandler(void)
{
 800159c:	b580      	push	{r7, lr}
 800159e:	af00      	add	r7, sp, #0
	if((CAN_ESR & (1<<0))==1)
 80015a0:	4b38      	ldr	r3, [pc, #224]	; (8001684 <CAN_SCE_IRQHandler+0xe8>)
 80015a2:	681b      	ldr	r3, [r3, #0]
 80015a4:	f003 0301 	and.w	r3, r3, #1
 80015a8:	2b01      	cmp	r3, #1
 80015aa:	d10a      	bne.n	80015c2 <CAN_SCE_IRQHandler+0x26>
	{
		//Error warning flag
		if(g_Can_Config.P_SCE_IRQ==NULL)
 80015ac:	4b36      	ldr	r3, [pc, #216]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 80015ae:	69db      	ldr	r3, [r3, #28]
 80015b0:	2b00      	cmp	r3, #0
 80015b2:	d102      	bne.n	80015ba <CAN_SCE_IRQHandler+0x1e>
		{
			MCAL_CAN_Error_Warning_Callback();
 80015b4:	f000 f86a 	bl	800168c <MCAL_CAN_Error_Warning_Callback>
				break;
			default:
				break;
		}
	}
}
 80015b8:	e061      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
			g_Can_Config.P_SCE_IRQ();
 80015ba:	4b33      	ldr	r3, [pc, #204]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 80015bc:	69db      	ldr	r3, [r3, #28]
 80015be:	4798      	blx	r3
}
 80015c0:	e05d      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
	else if((CAN_ESR & (1<<1))==1)
 80015c2:	4b30      	ldr	r3, [pc, #192]	; (8001684 <CAN_SCE_IRQHandler+0xe8>)
 80015c4:	681b      	ldr	r3, [r3, #0]
	else if((CAN_ESR & (1<<2))==1)
 80015c6:	4b2f      	ldr	r3, [pc, #188]	; (8001684 <CAN_SCE_IRQHandler+0xe8>)
 80015c8:	681b      	ldr	r3, [r3, #0]
		switch ((CAN_ESR>>4)&(7<<0))
 80015ca:	4b2e      	ldr	r3, [pc, #184]	; (8001684 <CAN_SCE_IRQHandler+0xe8>)
 80015cc:	681b      	ldr	r3, [r3, #0]
 80015ce:	091b      	lsrs	r3, r3, #4
 80015d0:	f003 0307 	and.w	r3, r3, #7
 80015d4:	3b01      	subs	r3, #1
 80015d6:	2b05      	cmp	r3, #5
 80015d8:	d850      	bhi.n	800167c <CAN_SCE_IRQHandler+0xe0>
 80015da:	a201      	add	r2, pc, #4	; (adr r2, 80015e0 <CAN_SCE_IRQHandler+0x44>)
 80015dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80015e0:	080015f9 	.word	0x080015f9
 80015e4:	0800160f 	.word	0x0800160f
 80015e8:	08001625 	.word	0x08001625
 80015ec:	0800163b 	.word	0x0800163b
 80015f0:	08001651 	.word	0x08001651
 80015f4:	08001667 	.word	0x08001667
				if(g_Can_Config.P_SCE_IRQ==NULL)
 80015f8:	4b23      	ldr	r3, [pc, #140]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 80015fa:	69db      	ldr	r3, [r3, #28]
 80015fc:	2b00      	cmp	r3, #0
 80015fe:	d102      	bne.n	8001606 <CAN_SCE_IRQHandler+0x6a>
					MCAL_CAN_Error_Stuff_Callback();
 8001600:	f000 f84a 	bl	8001698 <MCAL_CAN_Error_Stuff_Callback>
				break;
 8001604:	e03b      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 8001606:	4b20      	ldr	r3, [pc, #128]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001608:	69db      	ldr	r3, [r3, #28]
 800160a:	4798      	blx	r3
				break;
 800160c:	e037      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				if(g_Can_Config.P_SCE_IRQ==NULL)
 800160e:	4b1e      	ldr	r3, [pc, #120]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001610:	69db      	ldr	r3, [r3, #28]
 8001612:	2b00      	cmp	r3, #0
 8001614:	d102      	bne.n	800161c <CAN_SCE_IRQHandler+0x80>
					MCAL_CAN_Error_Form_Callback();
 8001616:	f000 f845 	bl	80016a4 <MCAL_CAN_Error_Form_Callback>
				break;
 800161a:	e030      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 800161c:	4b1a      	ldr	r3, [pc, #104]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 800161e:	69db      	ldr	r3, [r3, #28]
 8001620:	4798      	blx	r3
				break;
 8001622:	e02c      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				if(g_Can_Config.P_SCE_IRQ==NULL)
 8001624:	4b18      	ldr	r3, [pc, #96]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001626:	69db      	ldr	r3, [r3, #28]
 8001628:	2b00      	cmp	r3, #0
 800162a:	d102      	bne.n	8001632 <CAN_SCE_IRQHandler+0x96>
					MCAL_CAN_Error_Acknowledgment_Callback();
 800162c:	f000 f84c 	bl	80016c8 <MCAL_CAN_Error_Acknowledgment_Callback>
				break;
 8001630:	e025      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 8001632:	4b15      	ldr	r3, [pc, #84]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001634:	69db      	ldr	r3, [r3, #28]
 8001636:	4798      	blx	r3
				break;
 8001638:	e021      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				if(g_Can_Config.P_SCE_IRQ==NULL)
 800163a:	4b13      	ldr	r3, [pc, #76]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 800163c:	69db      	ldr	r3, [r3, #28]
 800163e:	2b00      	cmp	r3, #0
 8001640:	d102      	bne.n	8001648 <CAN_SCE_IRQHandler+0xac>
					MCAL_CAN_Error_Bit_Recessive_Callback();
 8001642:	f000 f835 	bl	80016b0 <MCAL_CAN_Error_Bit_Recessive_Callback>
				break;
 8001646:	e01a      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 8001648:	4b0f      	ldr	r3, [pc, #60]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 800164a:	69db      	ldr	r3, [r3, #28]
 800164c:	4798      	blx	r3
				break;
 800164e:	e016      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				if(g_Can_Config.P_SCE_IRQ==NULL)
 8001650:	4b0d      	ldr	r3, [pc, #52]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001652:	69db      	ldr	r3, [r3, #28]
 8001654:	2b00      	cmp	r3, #0
 8001656:	d102      	bne.n	800165e <CAN_SCE_IRQHandler+0xc2>
					MCAL_CAN_Error_Bit_Dominant_Callback();
 8001658:	f000 f830 	bl	80016bc <MCAL_CAN_Error_Bit_Dominant_Callback>
				break;
 800165c:	e00f      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 800165e:	4b0a      	ldr	r3, [pc, #40]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001660:	69db      	ldr	r3, [r3, #28]
 8001662:	4798      	blx	r3
				break;
 8001664:	e00b      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				if(g_Can_Config.P_SCE_IRQ==NULL)
 8001666:	4b08      	ldr	r3, [pc, #32]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001668:	69db      	ldr	r3, [r3, #28]
 800166a:	2b00      	cmp	r3, #0
 800166c:	d102      	bne.n	8001674 <CAN_SCE_IRQHandler+0xd8>
					MCAL_CAN_Error_CRC__Callback();
 800166e:	f000 f831 	bl	80016d4 <MCAL_CAN_Error_CRC__Callback>
				break;
 8001672:	e004      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
					g_Can_Config.P_SCE_IRQ();
 8001674:	4b04      	ldr	r3, [pc, #16]	; (8001688 <CAN_SCE_IRQHandler+0xec>)
 8001676:	69db      	ldr	r3, [r3, #28]
 8001678:	4798      	blx	r3
				break;
 800167a:	e000      	b.n	800167e <CAN_SCE_IRQHandler+0xe2>
				break;
 800167c:	bf00      	nop
}
 800167e:	bf00      	nop
 8001680:	bd80      	pop	{r7, pc}
 8001682:	bf00      	nop
 8001684:	40006418 	.word	0x40006418
 8001688:	200003ec 	.word	0x200003ec

0800168c <MCAL_CAN_Error_Warning_Callback>:
{

}

__attribute__((weak)) void MCAL_CAN_Error_Warning_Callback(void)
{
 800168c:	b480      	push	{r7}
 800168e:	af00      	add	r7, sp, #0

}
 8001690:	bf00      	nop
 8001692:	46bd      	mov	sp, r7
 8001694:	bc80      	pop	{r7}
 8001696:	4770      	bx	lr

08001698 <MCAL_CAN_Error_Stuff_Callback>:
__attribute__((weak)) void MCAL_CAN_Error_Stuff_Callback(void)
{
 8001698:	b480      	push	{r7}
 800169a:	af00      	add	r7, sp, #0

}
 800169c:	bf00      	nop
 800169e:	46bd      	mov	sp, r7
 80016a0:	bc80      	pop	{r7}
 80016a2:	4770      	bx	lr

080016a4 <MCAL_CAN_Error_Form_Callback>:
__attribute__((weak)) void MCAL_CAN_Error_Form_Callback(void)
{
 80016a4:	b480      	push	{r7}
 80016a6:	af00      	add	r7, sp, #0

}
 80016a8:	bf00      	nop
 80016aa:	46bd      	mov	sp, r7
 80016ac:	bc80      	pop	{r7}
 80016ae:	4770      	bx	lr

080016b0 <MCAL_CAN_Error_Bit_Recessive_Callback>:
__attribute__((weak)) void MCAL_CAN_Error_Bit_Recessive_Callback(void)
{
 80016b0:	b480      	push	{r7}
 80016b2:	af00      	add	r7, sp, #0

}
 80016b4:	bf00      	nop
 80016b6:	46bd      	mov	sp, r7
 80016b8:	bc80      	pop	{r7}
 80016ba:	4770      	bx	lr

080016bc <MCAL_CAN_Error_Bit_Dominant_Callback>:
__attribute__((weak)) void MCAL_CAN_Error_Bit_Dominant_Callback(void)
{
 80016bc:	b480      	push	{r7}
 80016be:	af00      	add	r7, sp, #0

}
 80016c0:	bf00      	nop
 80016c2:	46bd      	mov	sp, r7
 80016c4:	bc80      	pop	{r7}
 80016c6:	4770      	bx	lr

080016c8 <MCAL_CAN_Error_Acknowledgment_Callback>:
__attribute__((weak)) void MCAL_CAN_Error_Acknowledgment_Callback(void)
{
 80016c8:	b480      	push	{r7}
 80016ca:	af00      	add	r7, sp, #0

}
 80016cc:	bf00      	nop
 80016ce:	46bd      	mov	sp, r7
 80016d0:	bc80      	pop	{r7}
 80016d2:	4770      	bx	lr

080016d4 <MCAL_CAN_Error_CRC__Callback>:
__attribute__((weak)) void MCAL_CAN_Error_CRC__Callback(void)
{
 80016d4:	b480      	push	{r7}
 80016d6:	af00      	add	r7, sp, #0

}
 80016d8:	bf00      	nop
 80016da:	46bd      	mov	sp, r7
 80016dc:	bc80      	pop	{r7}
 80016de:	4770      	bx	lr

080016e0 <MCAL_CAN_Mailbox_0_Empty_Callback>:
__attribute__((weak)) void MCAL_CAN_Mailbox_0_Empty_Callback(void)
{
 80016e0:	b480      	push	{r7}
 80016e2:	af00      	add	r7, sp, #0

}
 80016e4:	bf00      	nop
 80016e6:	46bd      	mov	sp, r7
 80016e8:	bc80      	pop	{r7}
 80016ea:	4770      	bx	lr

080016ec <MCAL_CAN_FIFO_1_Receive_Callback>:
__attribute__((weak)) void MCAL_CAN_FIFO_0_Overrun_Callback(void)
{

}
__attribute__((weak)) void MCAL_CAN_FIFO_1_Receive_Callback(void)
{
 80016ec:	b480      	push	{r7}
 80016ee:	af00      	add	r7, sp, #0

}
 80016f0:	bf00      	nop
 80016f2:	46bd      	mov	sp, r7
 80016f4:	bc80      	pop	{r7}
 80016f6:	4770      	bx	lr

080016f8 <get_position>:

#include"stm32_f103c6_GPIO.h"


uint8_t get_position(uint16_t pinNumber)
{
 80016f8:	b480      	push	{r7}
 80016fa:	b083      	sub	sp, #12
 80016fc:	af00      	add	r7, sp, #0
 80016fe:	4603      	mov	r3, r0
 8001700:	80fb      	strh	r3, [r7, #6]
	switch(pinNumber)
 8001702:	88fb      	ldrh	r3, [r7, #6]
 8001704:	2b80      	cmp	r3, #128	; 0x80
 8001706:	d042      	beq.n	800178e <get_position+0x96>
 8001708:	2b80      	cmp	r3, #128	; 0x80
 800170a:	dc11      	bgt.n	8001730 <get_position+0x38>
 800170c:	2b08      	cmp	r3, #8
 800170e:	d036      	beq.n	800177e <get_position+0x86>
 8001710:	2b08      	cmp	r3, #8
 8001712:	dc06      	bgt.n	8001722 <get_position+0x2a>
 8001714:	2b02      	cmp	r3, #2
 8001716:	d02e      	beq.n	8001776 <get_position+0x7e>
 8001718:	2b04      	cmp	r3, #4
 800171a:	d02e      	beq.n	800177a <get_position+0x82>
 800171c:	2b01      	cmp	r3, #1
 800171e:	d028      	beq.n	8001772 <get_position+0x7a>
 8001720:	e047      	b.n	80017b2 <get_position+0xba>
 8001722:	2b20      	cmp	r3, #32
 8001724:	d02f      	beq.n	8001786 <get_position+0x8e>
 8001726:	2b40      	cmp	r3, #64	; 0x40
 8001728:	d02f      	beq.n	800178a <get_position+0x92>
 800172a:	2b10      	cmp	r3, #16
 800172c:	d029      	beq.n	8001782 <get_position+0x8a>
 800172e:	e040      	b.n	80017b2 <get_position+0xba>
 8001730:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8001734:	d033      	beq.n	800179e <get_position+0xa6>
 8001736:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800173a:	dc09      	bgt.n	8001750 <get_position+0x58>
 800173c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001740:	d029      	beq.n	8001796 <get_position+0x9e>
 8001742:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001746:	d028      	beq.n	800179a <get_position+0xa2>
 8001748:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800174c:	d021      	beq.n	8001792 <get_position+0x9a>
 800174e:	e030      	b.n	80017b2 <get_position+0xba>
 8001750:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001754:	d027      	beq.n	80017a6 <get_position+0xae>
 8001756:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800175a:	dc03      	bgt.n	8001764 <get_position+0x6c>
 800175c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001760:	d01f      	beq.n	80017a2 <get_position+0xaa>
 8001762:	e026      	b.n	80017b2 <get_position+0xba>
 8001764:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8001768:	d01f      	beq.n	80017aa <get_position+0xb2>
 800176a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800176e:	d01e      	beq.n	80017ae <get_position+0xb6>
 8001770:	e01f      	b.n	80017b2 <get_position+0xba>
	{
	case GPIO_PIN_0 :
		return 0;
 8001772:	2300      	movs	r3, #0
 8001774:	e01e      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_1 :
		return 4;
 8001776:	2304      	movs	r3, #4
 8001778:	e01c      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_2 :
		return 8;
 800177a:	2308      	movs	r3, #8
 800177c:	e01a      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_3 :
		return 12;
 800177e:	230c      	movs	r3, #12
 8001780:	e018      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_4 :
		return 16;
 8001782:	2310      	movs	r3, #16
 8001784:	e016      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_5 :
		return 20;
 8001786:	2314      	movs	r3, #20
 8001788:	e014      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_6 :
		return 24;
 800178a:	2318      	movs	r3, #24
 800178c:	e012      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_7 :
		return 28;
 800178e:	231c      	movs	r3, #28
 8001790:	e010      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_8 :
		return 0;
 8001792:	2300      	movs	r3, #0
 8001794:	e00e      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_9 :
		return 4;
 8001796:	2304      	movs	r3, #4
 8001798:	e00c      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_10 :
		return 8;
 800179a:	2308      	movs	r3, #8
 800179c:	e00a      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_11 :
		return 12;
 800179e:	230c      	movs	r3, #12
 80017a0:	e008      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_12 :
		return 16;
 80017a2:	2310      	movs	r3, #16
 80017a4:	e006      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_13 :
		return 20;
 80017a6:	2314      	movs	r3, #20
 80017a8:	e004      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_14 :
		return 24;
 80017aa:	2318      	movs	r3, #24
 80017ac:	e002      	b.n	80017b4 <get_position+0xbc>
		break;
	case GPIO_PIN_15 :
		return 28;
 80017ae:	231c      	movs	r3, #28
 80017b0:	e000      	b.n	80017b4 <get_position+0xbc>
		break;
	default:
		return 0;
 80017b2:	2300      	movs	r3, #0
	}
}
 80017b4:	4618      	mov	r0, r3
 80017b6:	370c      	adds	r7, #12
 80017b8:	46bd      	mov	sp, r7
 80017ba:	bc80      	pop	{r7}
 80017bc:	4770      	bx	lr

080017be <MCAL_GPIO_Init>:
* @param [in] 		-pinconfig: configuration information for the specified pin
* @retval 			-none
* Note				-stm32f103c6 has GPIO (A--->> E)but the LQFP48 package has GPIO (A---->> D)
*/
void MCAL_GPIO_Init(GPIO_TypeDef *GPIOx , GPIO_Pinconfig_t *pinconfig )
{
 80017be:	b590      	push	{r4, r7, lr}
 80017c0:	b085      	sub	sp, #20
 80017c2:	af00      	add	r7, sp, #0
 80017c4:	6078      	str	r0, [r7, #4]
 80017c6:	6039      	str	r1, [r7, #0]
	// GPIO->CRL configure pins 0-->>7
	// GPIO->CRH configure pins 8-->>15
	volatile uint32_t *configregister =NULL;
 80017c8:	2300      	movs	r3, #0
 80017ca:	60bb      	str	r3, [r7, #8]
	uint8_t pin_config=0;
 80017cc:	2300      	movs	r3, #0
 80017ce:	73fb      	strb	r3, [r7, #15]
	configregister = (pinconfig->pinNumber <GPIO_PIN_8) ? &GPIOx->CRL : &GPIOx->CRH ;
 80017d0:	683b      	ldr	r3, [r7, #0]
 80017d2:	881b      	ldrh	r3, [r3, #0]
 80017d4:	2bff      	cmp	r3, #255	; 0xff
 80017d6:	d801      	bhi.n	80017dc <MCAL_GPIO_Init+0x1e>
 80017d8:	687b      	ldr	r3, [r7, #4]
 80017da:	e001      	b.n	80017e0 <MCAL_GPIO_Init+0x22>
 80017dc:	687b      	ldr	r3, [r7, #4]
 80017de:	3304      	adds	r3, #4
 80017e0:	60bb      	str	r3, [r7, #8]
	//clear MODEy[1:0] and CNFy[1:0]
	(*configregister) &=~(0XF<<get_position(pinconfig->pinNumber));
 80017e2:	683b      	ldr	r3, [r7, #0]
 80017e4:	881b      	ldrh	r3, [r3, #0]
 80017e6:	4618      	mov	r0, r3
 80017e8:	f7ff ff86 	bl	80016f8 <get_position>
 80017ec:	4603      	mov	r3, r0
 80017ee:	461a      	mov	r2, r3
 80017f0:	230f      	movs	r3, #15
 80017f2:	4093      	lsls	r3, r2
 80017f4:	43da      	mvns	r2, r3
 80017f6:	68bb      	ldr	r3, [r7, #8]
 80017f8:	681b      	ldr	r3, [r3, #0]
 80017fa:	401a      	ands	r2, r3
 80017fc:	68bb      	ldr	r3, [r7, #8]
 80017fe:	601a      	str	r2, [r3, #0]
	//if pin is output
	if(pinconfig->GPIO_MODE == GPIO_MODE_OUTPUT_AF_OD || pinconfig->GPIO_MODE == GPIO_MODE_OUTPUT_AF_PP || pinconfig->GPIO_MODE == GPIO_MODE_OUTPUT_OD || pinconfig->GPIO_MODE == GPIO_MODE_OUTPUT_PP)
 8001800:	683b      	ldr	r3, [r7, #0]
 8001802:	789b      	ldrb	r3, [r3, #2]
 8001804:	2b07      	cmp	r3, #7
 8001806:	d00b      	beq.n	8001820 <MCAL_GPIO_Init+0x62>
 8001808:	683b      	ldr	r3, [r7, #0]
 800180a:	789b      	ldrb	r3, [r3, #2]
 800180c:	2b06      	cmp	r3, #6
 800180e:	d007      	beq.n	8001820 <MCAL_GPIO_Init+0x62>
 8001810:	683b      	ldr	r3, [r7, #0]
 8001812:	789b      	ldrb	r3, [r3, #2]
 8001814:	2b05      	cmp	r3, #5
 8001816:	d003      	beq.n	8001820 <MCAL_GPIO_Init+0x62>
 8001818:	683b      	ldr	r3, [r7, #0]
 800181a:	789b      	ldrb	r3, [r3, #2]
 800181c:	2b04      	cmp	r3, #4
 800181e:	d10e      	bne.n	800183e <MCAL_GPIO_Init+0x80>
	{
		//set MODEy[1:0] and CNFy[1:0]
		pin_config = ((((pinconfig->GPIO_MODE - 4) <<2) | (pinconfig->GPIO_OUTPUT_Speed)) & 0x0f);
 8001820:	683b      	ldr	r3, [r7, #0]
 8001822:	789b      	ldrb	r3, [r3, #2]
 8001824:	3b04      	subs	r3, #4
 8001826:	009b      	lsls	r3, r3, #2
 8001828:	b25a      	sxtb	r2, r3
 800182a:	683b      	ldr	r3, [r7, #0]
 800182c:	78db      	ldrb	r3, [r3, #3]
 800182e:	b25b      	sxtb	r3, r3
 8001830:	4313      	orrs	r3, r2
 8001832:	b25b      	sxtb	r3, r3
 8001834:	b2db      	uxtb	r3, r3
 8001836:	f003 030f 	and.w	r3, r3, #15
 800183a:	73fb      	strb	r3, [r7, #15]
 800183c:	e02c      	b.n	8001898 <MCAL_GPIO_Init+0xda>
	}
	//if pin is input
	else
	{
		if(pinconfig->GPIO_MODE == GPIO_MODE_INPUT_FLO || pinconfig->GPIO_MODE == GPIO_MODE_Analog)
 800183e:	683b      	ldr	r3, [r7, #0]
 8001840:	789b      	ldrb	r3, [r3, #2]
 8001842:	2b01      	cmp	r3, #1
 8001844:	d003      	beq.n	800184e <MCAL_GPIO_Init+0x90>
 8001846:	683b      	ldr	r3, [r7, #0]
 8001848:	789b      	ldrb	r3, [r3, #2]
 800184a:	2b00      	cmp	r3, #0
 800184c:	d107      	bne.n	800185e <MCAL_GPIO_Init+0xa0>
		{
			//set MODEy[1:0] and CNFy[1:0]
			pin_config = ((((pinconfig->GPIO_MODE) <<2)) &0x0f);
 800184e:	683b      	ldr	r3, [r7, #0]
 8001850:	789b      	ldrb	r3, [r3, #2]
 8001852:	009b      	lsls	r3, r3, #2
 8001854:	b2db      	uxtb	r3, r3
 8001856:	f003 030f 	and.w	r3, r3, #15
 800185a:	73fb      	strb	r3, [r7, #15]
 800185c:	e01c      	b.n	8001898 <MCAL_GPIO_Init+0xda>

		}
		else if(pinconfig->GPIO_MODE == GPIO_MODE_INPUT_AF)
 800185e:	683b      	ldr	r3, [r7, #0]
 8001860:	789b      	ldrb	r3, [r3, #2]
 8001862:	2b08      	cmp	r3, #8
 8001864:	d102      	bne.n	800186c <MCAL_GPIO_Init+0xae>
		{
			//set MODEy[1:0] and CNFy[1:0]
			pin_config = ((((GPIO_MODE_INPUT_FLO) <<2)) &0x0f);
 8001866:	2304      	movs	r3, #4
 8001868:	73fb      	strb	r3, [r7, #15]
 800186a:	e015      	b.n	8001898 <MCAL_GPIO_Init+0xda>
		}
		else
		{
			//set MODEy[1:0] and CNFy[1:0]
			pin_config = ((((GPIO_MODE_INPUT_PU) <<2)) &0x0f);
 800186c:	2308      	movs	r3, #8
 800186e:	73fb      	strb	r3, [r7, #15]
			if(pinconfig->GPIO_MODE == GPIO_MODE_INPUT_PU)
 8001870:	683b      	ldr	r3, [r7, #0]
 8001872:	789b      	ldrb	r3, [r3, #2]
 8001874:	2b02      	cmp	r3, #2
 8001876:	d107      	bne.n	8001888 <MCAL_GPIO_Init+0xca>
			{
				//  port bit configuration table px_ODR =1
				GPIOx->ODR  |=pinconfig->pinNumber;
 8001878:	687b      	ldr	r3, [r7, #4]
 800187a:	68db      	ldr	r3, [r3, #12]
 800187c:	683a      	ldr	r2, [r7, #0]
 800187e:	8812      	ldrh	r2, [r2, #0]
 8001880:	431a      	orrs	r2, r3
 8001882:	687b      	ldr	r3, [r7, #4]
 8001884:	60da      	str	r2, [r3, #12]
 8001886:	e007      	b.n	8001898 <MCAL_GPIO_Init+0xda>
			}
			else
			{
				//  port bit configuration table px_ODR =0
				GPIOx->ODR  &=~(pinconfig->pinNumber);
 8001888:	687b      	ldr	r3, [r7, #4]
 800188a:	68db      	ldr	r3, [r3, #12]
 800188c:	683a      	ldr	r2, [r7, #0]
 800188e:	8812      	ldrh	r2, [r2, #0]
 8001890:	43d2      	mvns	r2, r2
 8001892:	401a      	ands	r2, r3
 8001894:	687b      	ldr	r3, [r7, #4]
 8001896:	60da      	str	r2, [r3, #12]
			}
		}
	}
	(*configregister) |=(pin_config<<get_position(pinconfig->pinNumber));
 8001898:	7bfc      	ldrb	r4, [r7, #15]
 800189a:	683b      	ldr	r3, [r7, #0]
 800189c:	881b      	ldrh	r3, [r3, #0]
 800189e:	4618      	mov	r0, r3
 80018a0:	f7ff ff2a 	bl	80016f8 <get_position>
 80018a4:	4603      	mov	r3, r0
 80018a6:	fa04 f203 	lsl.w	r2, r4, r3
 80018aa:	68bb      	ldr	r3, [r7, #8]
 80018ac:	681b      	ldr	r3, [r3, #0]
 80018ae:	431a      	orrs	r2, r3
 80018b0:	68bb      	ldr	r3, [r7, #8]
 80018b2:	601a      	str	r2, [r3, #0]
}
 80018b4:	bf00      	nop
 80018b6:	3714      	adds	r7, #20
 80018b8:	46bd      	mov	sp, r7
 80018ba:	bd90      	pop	{r4, r7, pc}

080018bc <MCAL_GPIO_WritePin>:
* @param [in] 		-value: pin value
* @retval 			-none
* Note				-none
*/
void MCAL_GPIO_WritePin(GPIO_TypeDef *GPIOx ,uint16_t pinNumber ,uint8_t value)
{
 80018bc:	b480      	push	{r7}
 80018be:	b083      	sub	sp, #12
 80018c0:	af00      	add	r7, sp, #0
 80018c2:	6078      	str	r0, [r7, #4]
 80018c4:	460b      	mov	r3, r1
 80018c6:	807b      	strh	r3, [r7, #2]
 80018c8:	4613      	mov	r3, r2
 80018ca:	707b      	strb	r3, [r7, #1]
	if (value != GPIO_PIN_RESET)
 80018cc:	787b      	ldrb	r3, [r7, #1]
 80018ce:	2b00      	cmp	r3, #0
 80018d0:	d003      	beq.n	80018da <MCAL_GPIO_WritePin+0x1e>
		 Bits 15:0 BSy: Port x Set bit y (y= 0 .. 15)
		These bits are write-only and can be accessed in Word mode only.
		0: No action on the corresponding ODRx bit
		1: Set the corresponding ODRx bit
		 */
		GPIOx->BSRR= (uint32_t) pinNumber;
 80018d2:	887a      	ldrh	r2, [r7, #2]
 80018d4:	687b      	ldr	r3, [r7, #4]
 80018d6:	611a      	str	r2, [r3, #16]
		0: No action on the corresponding ODRx bit
		1: Reset the corresponding ODRx bit
		 */
		GPIOx->BRR= (uint32_t) pinNumber;
	}
}
 80018d8:	e002      	b.n	80018e0 <MCAL_GPIO_WritePin+0x24>
		GPIOx->BRR= (uint32_t) pinNumber;
 80018da:	887a      	ldrh	r2, [r7, #2]
 80018dc:	687b      	ldr	r3, [r7, #4]
 80018de:	615a      	str	r2, [r3, #20]
}
 80018e0:	bf00      	nop
 80018e2:	370c      	adds	r7, #12
 80018e4:	46bd      	mov	sp, r7
 80018e6:	bc80      	pop	{r7}
 80018e8:	4770      	bx	lr
	...

080018ec <__libc_init_array>:
 80018ec:	b570      	push	{r4, r5, r6, lr}
 80018ee:	2500      	movs	r5, #0
 80018f0:	4e0c      	ldr	r6, [pc, #48]	; (8001924 <__libc_init_array+0x38>)
 80018f2:	4c0d      	ldr	r4, [pc, #52]	; (8001928 <__libc_init_array+0x3c>)
 80018f4:	1ba4      	subs	r4, r4, r6
 80018f6:	10a4      	asrs	r4, r4, #2
 80018f8:	42a5      	cmp	r5, r4
 80018fa:	d109      	bne.n	8001910 <__libc_init_array+0x24>
 80018fc:	f000 f81a 	bl	8001934 <_init>
 8001900:	2500      	movs	r5, #0
 8001902:	4e0a      	ldr	r6, [pc, #40]	; (800192c <__libc_init_array+0x40>)
 8001904:	4c0a      	ldr	r4, [pc, #40]	; (8001930 <__libc_init_array+0x44>)
 8001906:	1ba4      	subs	r4, r4, r6
 8001908:	10a4      	asrs	r4, r4, #2
 800190a:	42a5      	cmp	r5, r4
 800190c:	d105      	bne.n	800191a <__libc_init_array+0x2e>
 800190e:	bd70      	pop	{r4, r5, r6, pc}
 8001910:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001914:	4798      	blx	r3
 8001916:	3501      	adds	r5, #1
 8001918:	e7ee      	b.n	80018f8 <__libc_init_array+0xc>
 800191a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800191e:	4798      	blx	r3
 8001920:	3501      	adds	r5, #1
 8001922:	e7f2      	b.n	800190a <__libc_init_array+0x1e>
 8001924:	08001958 	.word	0x08001958
 8001928:	08001958 	.word	0x08001958
 800192c:	08001958 	.word	0x08001958
 8001930:	0800195c 	.word	0x0800195c

08001934 <_init>:
 8001934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001936:	bf00      	nop
 8001938:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800193a:	bc08      	pop	{r3}
 800193c:	469e      	mov	lr, r3
 800193e:	4770      	bx	lr

08001940 <_fini>:
 8001940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001942:	bf00      	nop
 8001944:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001946:	bc08      	pop	{r3}
 8001948:	469e      	mov	lr, r3
 800194a:	4770      	bx	lr
